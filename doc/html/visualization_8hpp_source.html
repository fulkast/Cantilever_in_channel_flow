<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LB2D: visualization.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LB2D
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">visualization.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="visualization_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef LB_VISUALIZATION_HPP_INCLUDED</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define LB_VISUALIZATION_HPP_INCLUDED</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="simulation_8hpp.html">simulation.hpp</a>&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="opengl_8hpp.html">opengl.hpp</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="shader_8hpp.html">shader.hpp</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// unique_ptr</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;typeinfo&gt;</span> <span class="comment">// typeid</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;cstdlib&gt;</span> <span class="comment">// rand</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;third_party/EasyBMP/EasyBMP.h&quot;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">namespace </span>lb {
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00025"></a>00025 <span class="keyword">inline</span> T scale(T value, T min_value, T max_value)
<a name="l00026"></a>00026 {
<a name="l00027"></a>00027         <span class="keywordflow">return</span> (value - min_value) / (max_value - min_value);
<a name="l00028"></a>00028 }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keyword">class </span>visualization <span class="comment">// singleton</span>
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032 <span class="keyword">public</span>: <span class="comment">// ctors</span>
<a name="l00033"></a>00033         
<a name="l00034"></a>00034 <span class="preprocessor">        #if !defined(WIN32) &amp;&amp; !defined(__INTEL_COMPILER)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>        visualization(<span class="keyword">const</span> visualization&amp; other) = <span class="keyword">delete</span>;
<a name="l00036"></a>00036         visualization&amp; operator=(<span class="keyword">const</span> visualization&amp; other) = <span class="keyword">delete</span>;
<a name="l00037"></a>00037 <span class="preprocessor">        #else</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>        <span class="keyword">private</span>:
<a name="l00039"></a>00039         visualization(<span class="keyword">const</span> visualization&amp; other)
<a name="l00040"></a>00040         : panel_size(), dim_x(), dim_y(), buffer_size(), real_dim_x(), real_dim_y(), periodic_x(), periodic_y(), 
<a name="l00041"></a>00041           float_cast(), ibfv_alpha(), ibfv_texture_dim(), ibfv_sample_rate_x(), ibfv_sample_rate_y(), 
<a name="l00042"></a>00042           ibfv_additional_pts(), ibfv_grid_dim_x(), ibfv_grid_dim_y(), ibfv_scale(), ibfv_num_pattern(), num_modes() {}
<a name="l00043"></a>00043         visualization&amp; operator=(<span class="keyword">const</span> visualization&amp; other){ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00044"></a>00044 <span class="preprocessor">        #endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>        
<a name="l00046"></a>00046 <span class="keyword">private</span>: <span class="comment">// ctors</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048         visualization(simulation* _sim, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l00049"></a>00049         : <span class="comment">// window properties</span>
<a name="l00050"></a>00050           panel_size(170),
<a name="l00051"></a>00051           width(((800-panel_size)/_sim-&gt;l.nx)*(_sim-&gt;l.nx)+panel_size),
<a name="l00052"></a>00052           height(((800-panel_size)/_sim-&gt;l.nx)*(_sim-&gt;l.ny)),
<a name="l00053"></a>00053           <span class="comment">//width(std::min(static_cast&lt;int&gt;(600+panel_size), static_cast&lt;int&gt;(_sim-&gt;l.nx+panel_size))), </span>
<a name="l00054"></a>00054           <span class="comment">//height(std::min(static_cast&lt;int&gt;(600),static_cast&lt;int&gt;( _sim-&gt;l.ny))),</span>
<a name="l00055"></a>00055           <span class="comment">// pointer to simulation</span>
<a name="l00056"></a>00056           sim(_sim),
<a name="l00057"></a>00057           <span class="comment">// simulation properties</span>
<a name="l00058"></a>00058           dim_x(sim-&gt;l.nx),
<a name="l00059"></a>00059           dim_y(sim-&gt;l.ny),
<a name="l00060"></a>00060           buffer_size(sim-&gt;l.buffer_size),
<a name="l00061"></a>00061           real_dim_x(dim_x + 2*buffer_size),
<a name="l00062"></a>00062           real_dim_y(dim_y + 2*buffer_size),
<a name="l00063"></a>00063           periodic_x(sim-&gt;l.periodic_x),
<a name="l00064"></a>00064           periodic_y(sim-&gt;l.periodic_y),
<a name="l00065"></a>00065           <span class="comment">// if simulation does not use floats -&gt; cast every time</span>
<a name="l00066"></a>00066           float_cast(((typeid(<a class="code" href="namespacelb.html#a2b37d1585aef2d3da421ad0aedc6b11b">float_type</a>)==typeid(float)) ? false : true)),
<a name="l00067"></a>00067           rho_data_cast((float_cast ? real_dim_x*real_dim_y : 0),0),
<a name="l00068"></a>00068           u_data_cast((float_cast ? real_dim_x*real_dim_y : 0),0),
<a name="l00069"></a>00069           v_data_cast((float_cast ? real_dim_x*real_dim_y : 0),0),
<a name="l00070"></a>00070           <span class="comment">// wall container</span>
<a name="l00071"></a>00071           wall(real_dim_x*real_dim_y,0),
<a name="l00072"></a>00072           <span class="comment">// data pointers</span>
<a name="l00073"></a>00073           rho_data((float_cast ? &amp;rho_data_cast[0] : reinterpret_cast&lt;float*&gt;(&amp;(sim-&gt;l.rho[0])))),
<a name="l00074"></a>00074           u_data((float_cast ? &amp;u_data_cast[0] : reinterpret_cast&lt;float*&gt;(&amp;(sim-&gt;l.u[0])))),
<a name="l00075"></a>00075           v_data((float_cast ? &amp;v_data_cast[0] : reinterpret_cast&lt;float*&gt;(&amp;(sim-&gt;l.v[0])))),
<a name="l00076"></a>00076           wall_data(&amp;wall[0]),
<a name="l00077"></a>00077           <span class="comment">// opacity value for drawing</span>
<a name="l00078"></a>00078           alpha0(0.8),
<a name="l00079"></a>00079           <span class="comment">// ibfv params</span>
<a name="l00080"></a>00080           ibfv_alpha(0.12*255),<span class="comment">//(0.12*255),</span>
<a name="l00081"></a>00081           ibfv_texture_dim(64),
<a name="l00082"></a>00082           ibfv_sample_rate_x(std::max(dim_x/100, 1)),
<a name="l00083"></a>00083           ibfv_sample_rate_y(std::max(dim_y/100, 1)),
<a name="l00084"></a>00084           ibfv_additional_pts(5),
<a name="l00085"></a>00085           ibfv_grid_dim_x(dim_x/ibfv_sample_rate_x+2*ibfv_additional_pts),
<a name="l00086"></a>00086           ibfv_grid_dim_y(dim_y/ibfv_sample_rate_y+2*ibfv_additional_pts),
<a name="l00087"></a>00087           ibfv_scale(0.1),
<a name="l00088"></a>00088           ibfv_num_pattern(32),
<a name="l00089"></a>00089           frame_index(0),
<a name="l00090"></a>00090           ibfv_u_data(ibfv_grid_dim_x*ibfv_grid_dim_y,0),
<a name="l00091"></a>00091           ibfv_v_data(ibfv_grid_dim_x*ibfv_grid_dim_y,0),
<a name="l00092"></a>00092           ibfv_x_index_lookup(ibfv_grid_dim_x),
<a name="l00093"></a>00093           ibfv_y_index_lookup(ibfv_grid_dim_y),
<a name="l00094"></a>00094           <span class="comment">// opengl buffers (location and sizes)</span>
<a name="l00095"></a>00095           simulation_grid_vbo_size(real_dim_x*real_dim_y*4),
<a name="l00096"></a>00096           simulation_grid_ibo_size((real_dim_x-1)*(real_dim_y-1)*4),
<a name="l00097"></a>00097           field_vbo_size(real_dim_x*real_dim_y),
<a name="l00098"></a>00098           <span class="comment">// timings</span>
<a name="l00099"></a>00099           fps_hist(30),
<a name="l00100"></a>00100           fps_hist_index(0),
<a name="l00101"></a>00101           rho_max_hist(30,1.001),
<a name="l00102"></a>00102           rho_min_hist(30,0.999),
<a name="l00103"></a>00103           u_max_hist(30,sim-&gt;Vmax),
<a name="l00104"></a>00104           u_min_hist(30,-sim-&gt;Vmax),
<a name="l00105"></a>00105           v_max_hist(30,sim-&gt;Vmax),
<a name="l00106"></a>00106           v_min_hist(30,-sim-&gt;Vmax),
<a name="l00107"></a>00107           vel_mag2_max_hist(30,(sim-&gt;Vmax)*(sim-&gt;Vmax)),
<a name="l00108"></a>00108           vel_mag2_min_hist(30,0),
<a name="l00109"></a>00109           data_hist_index(0),
<a name="l00110"></a>00110           <span class="comment">// limits for simulation data</span>
<a name="l00111"></a>00111           min_rho(rho_min_hist[0]), max_rho(rho_max_hist[0]), 
<a name="l00112"></a>00112           min_u(u_min_hist[0]), max_u(u_max_hist[0]), 
<a name="l00113"></a>00113           min_v(v_min_hist[0]), max_v(v_max_hist[0]),
<a name="l00114"></a>00114           min_vel2(vel_mag2_min_hist[0]), max_vel2(vel_mag2_max_hist[0]),
<a name="l00115"></a>00115           <span class="comment">// sate flags</span>
<a name="l00116"></a>00116           running(0),
<a name="l00117"></a>00117           num_modes(8),
<a name="l00118"></a>00118           mode(0),
<a name="l00119"></a>00119           start_particles(true),
<a name="l00120"></a>00120           start_timeline(false),
<a name="l00121"></a>00121           picture_index(0)
<a name="l00122"></a>00122         {
<a name="l00123"></a>00123                 glutInit(&amp;argc, argv);
<a name="l00124"></a>00124                 glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
<a name="l00125"></a>00125                 glutInitWindowPosition(100,100);
<a name="l00126"></a>00126                 glutInitWindowSize(width,height);
<a name="l00127"></a>00127                 glutCreateWindow(<span class="stringliteral">&quot;2D Lattice Boltzmann&quot;</span>);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129                 glutDisplayFunc(&amp;visualization::display_function);
<a name="l00130"></a>00130                 glutIdleFunc(&amp;visualization::idle_function);
<a name="l00131"></a>00131                 glutReshapeFunc(&amp;visualization::reshape_function);
<a name="l00132"></a>00132                 glutKeyboardFunc(&amp;visualization::keybord_function);
<a name="l00133"></a>00133                 glutMouseFunc(&amp;visualization::mouse_function);
<a name="l00134"></a>00134                 glutMotionFunc(&amp;visualization::motion_function);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136                 <span class="comment">//      glEnable(GL_DEPTH_TEST);</span>
<a name="l00137"></a>00137                 <span class="comment">//      glClearColor(1.0,1.0,1.0,1.0);</span>
<a name="l00138"></a>00138                 <span class="comment">//      glEnable(GL_CULL_FACE);</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140                 glewInit();
<a name="l00141"></a>00141                 
<a name="l00142"></a>00142                 <span class="keywordflow">if</span> (glewIsSupported(<span class="stringliteral">&quot;GL_VERSION_2_0&quot;</span>)) std::cout &lt;&lt; <span class="stringliteral">&quot;Ready for OpenGL 2.0\n&quot;</span>;
<a name="l00143"></a>00143                 <span class="keywordflow">else</span> <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;OpenGL 2.0 not supported&quot;</span>);
<a name="l00144"></a>00144                 
<a name="l00145"></a>00145                 <span class="comment">// load the shaders</span>
<a name="l00146"></a>00146                 vel_mag_shader_ptr = std::unique_ptr&lt;shader&gt;( <span class="keyword">new</span> shader() );
<a name="l00147"></a>00147                 rho_shader_ptr  = std::unique_ptr&lt;shader&gt;( <span class="keyword">new</span> shader() );
<a name="l00148"></a>00148                 u_shader_ptr  = std::unique_ptr&lt;shader&gt;( <span class="keyword">new</span> shader() );
<a name="l00149"></a>00149                 v_shader_ptr  = std::unique_ptr&lt;shader&gt;( <span class="keyword">new</span> shader() );
<a name="l00150"></a>00150                 wall_shader_ptr = std::unique_ptr&lt;shader&gt;( <span class="keyword">new</span> shader() );
<a name="l00151"></a>00151                 
<a name="l00152"></a>00152                 
<a name="l00153"></a>00153 <span class="preprocessor">                #if !defined(WIN32) &amp;&amp; !defined(__INTEL_COMPILER)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span>                vel_mag_shader_ptr-&gt;load(std::vector&lt;std::string&gt;({<span class="stringliteral">&quot;shaders/jet_color_map.glsl&quot;</span>, <span class="stringliteral">&quot;shaders/velocity_magnitude.vert&quot;</span>}), <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00155"></a>00155                 rho_shader_ptr-&gt;load(std::vector&lt;std::string&gt;({<span class="stringliteral">&quot;shaders/jet_color_map.glsl&quot;</span>, <span class="stringliteral">&quot;shaders/scalar.vert&quot;</span>}), <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00156"></a>00156                 u_shader_ptr-&gt;load(std::vector&lt;std::string&gt;({<span class="stringliteral">&quot;shaders/jet_color_map.glsl&quot;</span>, <span class="stringliteral">&quot;shaders/scalar.vert&quot;</span>}), <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00157"></a>00157                 v_shader_ptr-&gt;load(std::vector&lt;std::string&gt;({<span class="stringliteral">&quot;shaders/jet_color_map.glsl&quot;</span>, <span class="stringliteral">&quot;shaders/scalar.vert&quot;</span>}), <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00158"></a>00158                 wall_shader_ptr-&gt;load(<span class="stringliteral">&quot;shaders/wall.vert&quot;</span>, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00159"></a>00159 <span class="preprocessor">                #else</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>                std::vector&lt;std::string&gt; shader_names;
<a name="l00161"></a>00161                 shader_names.push_back(<span class="stringliteral">&quot;shaders/jet_color_map.glsl&quot;</span>);
<a name="l00162"></a>00162                 shader_names.push_back(<span class="stringliteral">&quot;shaders/velocity_magnitude.vert&quot;</span>);
<a name="l00163"></a>00163                 vel_mag_shader_ptr-&gt;load(shader_names, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00164"></a>00164                 shader_names[1] = <span class="stringliteral">&quot;shaders/scalar.vert&quot;</span>;
<a name="l00165"></a>00165                 rho_shader_ptr-&gt;load(shader_names, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00166"></a>00166                 u_shader_ptr-&gt;load(shader_names, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00167"></a>00167                 v_shader_ptr-&gt;load(shader_names, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00168"></a>00168                 wall_shader_ptr-&gt;load(<span class="stringliteral">&quot;shaders/wall.vert&quot;</span>, <span class="stringliteral">&quot;shaders/trivial.frag&quot;</span>);
<a name="l00169"></a>00169 <span class="preprocessor">                #endif</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>                GLint location;
<a name="l00171"></a>00171                 
<a name="l00172"></a>00172                 <span class="comment">// create simulation grid geometry</span>
<a name="l00173"></a>00173                 <span class="comment">// -------------------------------</span>
<a name="l00174"></a>00174                 <span class="comment">// vertex buffer object</span>
<a name="l00175"></a>00175                 <span class="keywordtype">float</span> dx = 2.0/(dim_x-1);
<a name="l00176"></a>00176                 <span class="keywordtype">float</span> dy = 2.0/(dim_y-1);
<a name="l00177"></a>00177                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k(0);
<a name="l00178"></a>00178                 std::vector&lt;float&gt; vertices(simulation_grid_vbo_size);
<a name="l00179"></a>00179                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=-buffer_size; j&lt;dim_y+buffer_size; ++j)
<a name="l00180"></a>00180                 {
<a name="l00181"></a>00181                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-buffer_size; i&lt;dim_x+buffer_size; ++i)
<a name="l00182"></a>00182                         {
<a name="l00183"></a>00183                                 vertices[k++] = -1.0 + i*dx;
<a name="l00184"></a>00184                                 vertices[k++] = -1.0 + j*dx;
<a name="l00185"></a>00185                                 vertices[k++] = 0.0;
<a name="l00186"></a>00186                                 vertices[k++] = 1.0;
<a name="l00187"></a>00187                         }
<a name="l00188"></a>00188                 }
<a name="l00189"></a>00189                 <span class="comment">// make buffer, bind it and fill with values</span>
<a name="l00190"></a>00190                 simulation_grid_vbo = make_buffer(GL_ARRAY_BUFFER, &amp;vertices[0], simulation_grid_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), GL_STATIC_DRAW);
<a name="l00191"></a>00191                 location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;position&quot;</span>);
<a name="l00192"></a>00192                 glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00193"></a>00193                 glEnableVertexAttribArray(location);
<a name="l00194"></a>00194                 location = rho_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;position&quot;</span>);
<a name="l00195"></a>00195                 glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00196"></a>00196                 glEnableVertexAttribArray(location);
<a name="l00197"></a>00197                 location = u_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;position&quot;</span>);
<a name="l00198"></a>00198                 glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00199"></a>00199                 glEnableVertexAttribArray(location);
<a name="l00200"></a>00200                 location = v_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;position&quot;</span>);
<a name="l00201"></a>00201                 glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00202"></a>00202                 glEnableVertexAttribArray(location);
<a name="l00203"></a>00203                 location = wall_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;position&quot;</span>);
<a name="l00204"></a>00204                 glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00205"></a>00205                 glEnableVertexAttribArray(location);
<a name="l00206"></a>00206                 
<a name="l00207"></a>00207                 <span class="comment">// index buffer object</span>
<a name="l00208"></a>00208                 k=0;
<a name="l00209"></a>00209                 std::vector&lt;unsigned int&gt; indices(simulation_grid_ibo_size);
<a name="l00210"></a>00210                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;real_dim_y-1; ++j)
<a name="l00211"></a>00211                 {
<a name="l00212"></a>00212                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;real_dim_x-1; ++i)
<a name="l00213"></a>00213                         {
<a name="l00214"></a>00214                                 indices[k++] = j*real_dim_x + i + 0;
<a name="l00215"></a>00215                                 indices[k++] = j*real_dim_x + i + 1;
<a name="l00216"></a>00216                                 indices[k++] = (j+1)*real_dim_x + i + 1;
<a name="l00217"></a>00217                                 indices[k++] = (j+1)*real_dim_x + i + 0;
<a name="l00218"></a>00218                         }
<a name="l00219"></a>00219                 }
<a name="l00220"></a>00220                 <span class="comment">// make buffer, bind it and fill with values</span>
<a name="l00221"></a>00221                 simulation_grid_ibo = make_buffer(GL_ELEMENT_ARRAY_BUFFER, &amp;indices[0], simulation_grid_ibo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), GL_STATIC_DRAW);
<a name="l00222"></a>00222                 
<a name="l00223"></a>00223                 <span class="comment">// create field buffers</span>
<a name="l00224"></a>00224                 <span class="comment">// --------------------</span>
<a name="l00225"></a>00225                 <span class="comment">// make rho buffer, bind it and fill with values</span>
<a name="l00226"></a>00226                 rho_vbo = make_buffer(GL_ARRAY_BUFFER, rho_data, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), GL_DYNAMIC_DRAW);
<a name="l00227"></a>00227                 <span class="comment">// make shader attribute</span>
<a name="l00228"></a>00228                 location = rho_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00229"></a>00229                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00230"></a>00230                 glEnableVertexAttribArray(location);
<a name="l00231"></a>00231                 
<a name="l00232"></a>00232                 <span class="comment">// make u buffer, bind it and fill with values</span>
<a name="l00233"></a>00233                 u_vbo = make_buffer(GL_ARRAY_BUFFER, u_data, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), GL_DYNAMIC_DRAW);
<a name="l00234"></a>00234                 <span class="comment">// make shader attribute</span>
<a name="l00235"></a>00235                 location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;u&quot;</span>);
<a name="l00236"></a>00236                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00237"></a>00237                 glEnableVertexAttribArray(location);
<a name="l00238"></a>00238                 location = u_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00239"></a>00239                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00240"></a>00240                 glEnableVertexAttribArray(location);
<a name="l00241"></a>00241                 
<a name="l00242"></a>00242                 <span class="comment">// make v buffer, bind it and fill with values</span>
<a name="l00243"></a>00243                 v_vbo = make_buffer(GL_ARRAY_BUFFER, v_data, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), GL_DYNAMIC_DRAW);
<a name="l00244"></a>00244                 <span class="comment">// make shader attribute</span>
<a name="l00245"></a>00245                 location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;v&quot;</span>);
<a name="l00246"></a>00246                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00247"></a>00247                 glEnableVertexAttribArray(location);
<a name="l00248"></a>00248                 location = v_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00249"></a>00249                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00250"></a>00250                 glEnableVertexAttribArray(location);
<a name="l00251"></a>00251                 
<a name="l00252"></a>00252                 <span class="comment">// query walls</span>
<a name="l00253"></a>00253                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;real_dim_x*real_dim_y; ++k)
<a name="l00254"></a>00254                 {
<a name="l00255"></a>00255                         wall[k] = (sim-&gt;l.properties.has_flag_property(<span class="stringliteral">&quot;wall&quot;</span>,k) ? 1 : 0);
<a name="l00256"></a>00256                 }
<a name="l00257"></a>00257                 <span class="comment">// make v buffer, bind it and fill with values</span>
<a name="l00258"></a>00258                 wall_vbo = make_buffer(GL_ARRAY_BUFFER, wall_data, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), GL_STATIC_DRAW);
<a name="l00259"></a>00259                 <span class="comment">// make shader attribute</span>
<a name="l00260"></a>00260                 location = wall_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;wall&quot;</span>);
<a name="l00261"></a>00261                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00262"></a>00262                 glEnableVertexAttribArray(location);
<a name="l00263"></a>00263                 
<a name="l00264"></a>00264                 <span class="comment">// set texture states for ibfv</span>
<a name="l00265"></a>00265                 <span class="keywordflow">if</span> (periodic_x) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); 
<a name="l00266"></a>00266                 <span class="keywordflow">else</span> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); 
<a name="l00267"></a>00267                 <span class="keywordflow">if</span> (periodic_y) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 
<a name="l00268"></a>00268                 <span class="keywordflow">else</span> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); 
<a name="l00269"></a>00269                 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<a name="l00270"></a>00270                 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
<a name="l00271"></a>00271                 glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
<a name="l00272"></a>00272                 <span class="comment">//glShadeModel(GL_FLAT);</span>
<a name="l00273"></a>00273                 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
<a name="l00274"></a>00274                 
<a name="l00275"></a>00275                 make_patterns();
<a name="l00276"></a>00276                 
<a name="l00277"></a>00277                 <span class="comment">// setup 2d pixel plotting camera</span>
<a name="l00278"></a>00278                 glMatrixMode(GL_PROJECTION);
<a name="l00279"></a>00279                 glLoadIdentity();
<a name="l00280"></a>00280                 glOrtho(0.0f, width, 0.0f, height, 0.0f, 1.0f);
<a name="l00281"></a>00281                 glMatrixMode(GL_MODELVIEW);
<a name="l00282"></a>00282                 glLoadIdentity();
<a name="l00283"></a>00283                 
<a name="l00284"></a>00284                 print_usage();
<a name="l00285"></a>00285         }
<a name="l00286"></a>00286         
<a name="l00287"></a>00287 <span class="keyword">public</span>: <span class="comment">// static functions</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(simulation* sim, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l00290"></a>00290         {
<a name="l00291"></a>00291                 <span class="keywordflow">if</span> (!vis) vis = std::unique_ptr&lt;visualization&gt;( <span class="keyword">new</span> visualization(sim,argc,argv) );
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293         
<a name="l00294"></a>00294         <span class="keyword">static</span> visualization&amp; get_instance()
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296                 <span class="keywordflow">if</span> (vis) <span class="keywordflow">return</span> *vis;
<a name="l00297"></a>00297                 <span class="keywordflow">else</span> <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;visualization is not initialized&quot;</span>);
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300         <span class="keyword">static</span> <span class="keywordtype">void</span> display_function() { get_instance().display(); glutPostRedisplay(); }
<a name="l00301"></a>00301         
<a name="l00302"></a>00302         <span class="keyword">static</span> <span class="keywordtype">void</span> idle_function() { get_instance().idle(); }
<a name="l00303"></a>00303         
<a name="l00304"></a>00304         <span class="keyword">static</span> <span class="keywordtype">void</span> reshape_function(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h) { get_instance().reshape(w,h); }
<a name="l00305"></a>00305         
<a name="l00306"></a>00306         <span class="keyword">static</span> <span class="keywordtype">void</span> keybord_function(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) 
<a name="l00307"></a>00307         { 
<a name="l00308"></a>00308                 get_instance().keybord(key,x,y); 
<a name="l00309"></a>00309                 <span class="keywordflow">if</span>(key == 27) <span class="comment">// ESC</span>
<a name="l00310"></a>00310                 {
<a name="l00311"></a>00311                         vis.release();
<a name="l00312"></a>00312                         exit(0);
<a name="l00313"></a>00313                 }
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315         
<a name="l00316"></a>00316         <span class="keyword">static</span> <span class="keywordtype">void</span> motion_function(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00317"></a>00317         {
<a name="l00318"></a>00318                 get_instance().motion(x,y);
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320         
<a name="l00321"></a>00321         <span class="keyword">static</span> <span class="keywordtype">void</span> mouse_function(<span class="keywordtype">int</span> button, <span class="keywordtype">int</span> state, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00322"></a>00322         {
<a name="l00323"></a>00323                 get_instance().mouse(button,state,x,y);
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325         
<a name="l00326"></a>00326 <span class="keyword">public</span>: <span class="comment">// opengl callback functions</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328         <span class="keywordtype">void</span> run()
<a name="l00329"></a>00329         {
<a name="l00330"></a>00330                 start_time = timer_type::now();
<a name="l00331"></a>00331                 last_display_time = start_time;
<a name="l00332"></a>00332                 glutMainLoop();
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334         
<a name="l00335"></a>00335         <span class="keywordtype">void</span> reshape(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
<a name="l00336"></a>00336         {
<a name="l00337"></a>00337                 glViewport(0, 0, w, h);
<a name="l00338"></a>00338                 width = w;
<a name="l00339"></a>00339                 height = h;
<a name="l00340"></a>00340                 <span class="comment">// setup 2d pixel plotting camera</span>
<a name="l00341"></a>00341                 glMatrixMode(GL_PROJECTION);
<a name="l00342"></a>00342                 glLoadIdentity();
<a name="l00343"></a>00343                 glOrtho(0.0f, width, 0.0f, height, 0.0f, 1.0f);
<a name="l00344"></a>00344                 glMatrixMode(GL_MODELVIEW);
<a name="l00345"></a>00345                 glLoadIdentity();
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347         
<a name="l00348"></a>00348         <span class="keywordtype">void</span> display()
<a name="l00349"></a>00349         {
<a name="l00350"></a>00350                 <a class="code" href="namespacelb.html#a664b98bd4013970d2005405e23ef78d9">time_point</a> current_time_point = timer_type::now();
<a name="l00351"></a>00351                 <a class="code" href="namespacelb.html#ac6197d62b7eeafa021fdcf0a45fa3bfe">duration</a> dt_d = current_time_point - last_display_time;
<a name="l00352"></a>00352                 last_display_time = current_time_point;
<a name="l00353"></a>00353                 current_time = std::chrono::duration_cast&lt;<a class="code" href="namespacelb.html#a91eab8920da42c1c74728a490c58ec76">milliseconds</a>&gt;(current_time_point - start_time).count();
<a name="l00354"></a>00354                 dt = std::chrono::duration_cast&lt;<a class="code" href="namespacelb.html#a91eab8920da42c1c74728a490c58ec76">milliseconds</a>&gt;(dt_d).count();
<a name="l00355"></a>00355                 fps_hist[fps_hist_index] = 1000.0/dt;
<a name="l00356"></a>00356                 fps_hist_index = (fps_hist_index + 1) % fps_hist.size();
<a name="l00357"></a>00357                 <span class="keywordtype">float</span> fps(0);
<a name="l00358"></a>00358                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fps_hist.size(); ++i) fps+=fps_hist[i];
<a name="l00359"></a>00359                 fps/=fps_hist.size();
<a name="l00360"></a>00360                 
<a name="l00361"></a>00361                 <span class="keyword">static</span> <span class="keywordtype">float</span> dummy_pos = 0.0f;
<a name="l00362"></a>00362                 <span class="keyword">static</span> <span class="keywordtype">int</span> num_time_steps = 0;
<a name="l00363"></a>00363                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_steps = 15;<span class="comment">//25;</span>
<a name="l00364"></a>00364                 
<a name="l00365"></a>00365                 <span class="keywordflow">if</span> (running)
<a name="l00366"></a>00366                 {
<a name="l00367"></a>00367                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;num_steps; ++i) sim-&gt;step();
<a name="l00368"></a>00368                         
<a name="l00369"></a>00369                         
<a name="l00370"></a>00370                         <span class="keywordflow">if</span> (float_cast)
<a name="l00371"></a>00371                         {
<a name="l00372"></a>00372                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;real_dim_x*real_dim_y; ++k)
<a name="l00373"></a>00373                                 {
<a name="l00374"></a>00374                                         rho_data_cast[k] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(sim-&gt;l.rho[k]);
<a name="l00375"></a>00375                                         u_data_cast[k] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(sim-&gt;l.u[k]);
<a name="l00376"></a>00376                                         v_data_cast[k] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(sim-&gt;l.v[k]);
<a name="l00377"></a>00377                                 }
<a name="l00378"></a>00378                         }
<a name="l00379"></a>00379                         <span class="keywordtype">float</span> rho_min = 999999; <span class="keywordtype">float</span> rho_max=-999999;
<a name="l00380"></a>00380                         <span class="keywordtype">float</span> u_min = 999999; <span class="keywordtype">float</span> u_max=-999999;
<a name="l00381"></a>00381                         <span class="keywordtype">float</span> v_min = 999999; <span class="keywordtype">float</span> v_max=-999999;
<a name="l00382"></a>00382                         <span class="keywordtype">float</span> vel2_min = 999999; <span class="keywordtype">float</span> vel2_max=-999999;
<a name="l00383"></a>00383                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim_y; ++j)
<a name="l00384"></a>00384                         {
<a name="l00385"></a>00385                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim_x; ++i)
<a name="l00386"></a>00386                                 {
<a name="l00387"></a>00387                                         <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = rho_data[(j+buffer_size)*real_dim_x + i + buffer_size];
<a name="l00388"></a>00388                                         rho_min = std::min(rho_min,tmp);
<a name="l00389"></a>00389                                         rho_max = std::max(rho_max,tmp);
<a name="l00390"></a>00390                                 }
<a name="l00391"></a>00391                         }
<a name="l00392"></a>00392                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim_y; ++j)
<a name="l00393"></a>00393                         {
<a name="l00394"></a>00394                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim_x; ++i)
<a name="l00395"></a>00395                                 {
<a name="l00396"></a>00396                                         <span class="keyword">const</span> <span class="keywordtype">float</span> tmpu = u_data[(j+buffer_size)*real_dim_x + i + buffer_size];
<a name="l00397"></a>00397                                         <span class="keyword">const</span> <span class="keywordtype">float</span> tmpv = v_data[(j+buffer_size)*real_dim_x + i + buffer_size];
<a name="l00398"></a>00398                                         u_min = std::min(u_min,tmpu);
<a name="l00399"></a>00399                                         u_max = std::max(u_max,tmpu);
<a name="l00400"></a>00400                                         v_min = std::min(v_min,tmpv);
<a name="l00401"></a>00401                                         v_max = std::max(v_max,tmpv);
<a name="l00402"></a>00402                                         vel2_min = std::min(vel2_min,tmpu*tmpu + tmpv*tmpv);
<a name="l00403"></a>00403                                         vel2_max = std::max(vel2_max,tmpu*tmpu + tmpv*tmpv);
<a name="l00404"></a>00404                                 }
<a name="l00405"></a>00405                         }
<a name="l00406"></a>00406                         <span class="keywordflow">if</span> (num_time_steps == 0)
<a name="l00407"></a>00407                         {
<a name="l00408"></a>00408                                 rho_min_hist = std::vector&lt;float&gt;(30,rho_min);
<a name="l00409"></a>00409                                 rho_max_hist = std::vector&lt;float&gt;(30,rho_max);
<a name="l00410"></a>00410                                 u_min_hist = std::vector&lt;float&gt;(30,u_min);
<a name="l00411"></a>00411                                 u_max_hist = std::vector&lt;float&gt;(30,u_max);
<a name="l00412"></a>00412                                 v_min_hist = std::vector&lt;float&gt;(30,v_min);
<a name="l00413"></a>00413                                 v_max_hist = std::vector&lt;float&gt;(30,v_max);
<a name="l00414"></a>00414                                 vel_mag2_min_hist = std::vector&lt;float&gt;(30,vel2_min);
<a name="l00415"></a>00415                                 vel_mag2_max_hist = std::vector&lt;float&gt;(30,vel2_max);
<a name="l00416"></a>00416                         }
<a name="l00417"></a>00417                         <span class="keywordflow">else</span>
<a name="l00418"></a>00418                         {
<a name="l00419"></a>00419                                 rho_min_hist[data_hist_index] = rho_min;
<a name="l00420"></a>00420                                 rho_max_hist[data_hist_index] = rho_max;
<a name="l00421"></a>00421                                 u_min_hist[data_hist_index] = u_min;
<a name="l00422"></a>00422                                 u_max_hist[data_hist_index] = u_max;
<a name="l00423"></a>00423                                 v_min_hist[data_hist_index] = v_min;
<a name="l00424"></a>00424                                 v_max_hist[data_hist_index] = v_max;
<a name="l00425"></a>00425                                 vel_mag2_min_hist[data_hist_index] = vel2_min;
<a name="l00426"></a>00426                                 vel_mag2_max_hist[data_hist_index] = vel2_max;
<a name="l00427"></a>00427                         }
<a name="l00428"></a>00428                         max_rho = 0; min_rho = 0; max_u = 0; min_u = 0; max_v = 0; min_v = 0; max_vel2 = 0; min_vel2 = 0;
<a name="l00429"></a>00429                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;rho_max_hist.size(); ++i)
<a name="l00430"></a>00430                         {
<a name="l00431"></a>00431                                 max_rho += rho_max_hist[i];
<a name="l00432"></a>00432                                 min_rho += rho_min_hist[i];
<a name="l00433"></a>00433                                 max_u += u_max_hist[i];
<a name="l00434"></a>00434                                 min_u += u_min_hist[i];
<a name="l00435"></a>00435                                 max_v += v_max_hist[i];
<a name="l00436"></a>00436                                 min_v += v_min_hist[i];
<a name="l00437"></a>00437                                 max_vel2 += vel_mag2_max_hist[i];
<a name="l00438"></a>00438                                 min_vel2 += vel_mag2_min_hist[i];
<a name="l00439"></a>00439                         }
<a name="l00440"></a>00440                         max_rho /= rho_max_hist.size();
<a name="l00441"></a>00441                         min_rho /= rho_max_hist.size();
<a name="l00442"></a>00442                         max_u /= rho_max_hist.size();
<a name="l00443"></a>00443                         min_u /= rho_max_hist.size();
<a name="l00444"></a>00444                         max_v /= rho_max_hist.size();
<a name="l00445"></a>00445                         min_v /= rho_max_hist.size();
<a name="l00446"></a>00446                         max_vel2 /= rho_max_hist.size();
<a name="l00447"></a>00447                         min_vel2 /= rho_max_hist.size();
<a name="l00448"></a>00448                         data_hist_index = (data_hist_index+1) % rho_max_hist.size();
<a name="l00449"></a>00449                         
<a name="l00450"></a>00450                         num_time_steps += num_steps;
<a name="l00451"></a>00451                 }
<a name="l00452"></a>00452                 
<a name="l00453"></a>00453                 <span class="comment">// clear screen</span>
<a name="l00454"></a>00454                 glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
<a name="l00455"></a>00455                 glClear(GL_COLOR_BUFFER_BIT);
<a name="l00456"></a>00456                 
<a name="l00457"></a>00457                 glViewport(0, 0, width, height);
<a name="l00458"></a>00458                 screen_text(width-panel_size+20, height-230, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;step:&quot;</span>);
<a name="l00459"></a>00459                 screen_text(width-panel_size+60, height-230, 1.0, 1.0, 1.0, std::to_string(num_time_steps));
<a name="l00460"></a>00460                 screen_text(width-panel_size+20, height-245, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;fps:&quot;</span>);
<a name="l00461"></a>00461                 screen_text(width-panel_size+60, height-245, 1.0, 1.0, 1.0, std::to_string(fps));
<a name="l00462"></a>00462                 screen_text(width-panel_size+20, height-290, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;exit:&quot;</span>);
<a name="l00463"></a>00463                 screen_text(width-panel_size+60, height-290, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;&lt;esc&gt;&quot;</span>);
<a name="l00464"></a>00464                 screen_text(width-panel_size+20, height-305, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;start:&quot;</span>);
<a name="l00465"></a>00465                 screen_text(width-panel_size+60, height-305, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;&lt;space&gt;&quot;</span>);
<a name="l00466"></a>00466                 screen_text(width-panel_size+20, height-320, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;mode:&quot;</span>);
<a name="l00467"></a>00467                 screen_text(width-panel_size+60, height-320, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;&lt;m&gt;&quot;</span>);
<a name="l00468"></a>00468                 screen_text(width-panel_size+20, height-335, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;save:&quot;</span>);
<a name="l00469"></a>00469                 screen_text(width-panel_size+60, height-335, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;&lt;s&gt;&quot;</span>);
<a name="l00470"></a>00470                 <span class="keywordflow">if</span> (mode == 5)
<a name="l00471"></a>00471                 {
<a name="l00472"></a>00472                         screen_text(width-panel_size+20, height-365, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;use left mouse button to&quot;</span>);
<a name="l00473"></a>00473                         screen_text(width-panel_size+20, height-380, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;create new particles&quot;</span>);
<a name="l00474"></a>00474                 }
<a name="l00475"></a>00475                 <span class="keywordflow">if</span> (mode == 7)
<a name="l00476"></a>00476                 {
<a name="l00477"></a>00477                         screen_text(width-panel_size+20, height-365, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;use &lt;r&gt; to restart&quot;</span>);
<a name="l00478"></a>00478                 }
<a name="l00479"></a>00479                 
<a name="l00480"></a>00480                 glViewport(0, 0, width-panel_size, height);
<a name="l00481"></a>00481                 
<a name="l00482"></a>00482                 <span class="keywordflow">if</span> (mode == 0) <span class="comment">// velocity magnitude</span>
<a name="l00483"></a>00483                 {
<a name="l00484"></a>00484                         glBindBuffer(GL_ARRAY_BUFFER, u_vbo);
<a name="l00485"></a>00485                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), u_data, GL_DYNAMIC_DRAW);
<a name="l00486"></a>00486                         GLint location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;u&quot;</span>);
<a name="l00487"></a>00487                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00488"></a>00488                         glEnableVertexAttribArray(location);
<a name="l00489"></a>00489                         glBindBuffer(GL_ARRAY_BUFFER, v_vbo);
<a name="l00490"></a>00490                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), v_data, GL_DYNAMIC_DRAW);
<a name="l00491"></a>00491                         location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;v&quot;</span>);
<a name="l00492"></a>00492                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00493"></a>00493                         glEnableVertexAttribArray(location);
<a name="l00494"></a>00494                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;max_magnitude2&quot;</span>,max_vel2);<span class="comment">//max_u*max_u*0.2f);</span>
<a name="l00495"></a>00495                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;min_magnitude2&quot;</span>,min_vel2);
<a name="l00496"></a>00496                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;alpha&quot;</span>,1.0f);
<a name="l00497"></a>00497                         vel_mag_shader_ptr-&gt;activate();
<a name="l00498"></a>00498                         GL_CHECK_AND_PRINT_ERROR
<a name="l00499"></a>00499                         glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00500"></a>00500                         GL_CHECK_AND_PRINT_ERROR
<a name="l00501"></a>00501                         vel_mag_shader_ptr-&gt;deactivate();
<a name="l00502"></a>00502                         
<a name="l00503"></a>00503                         draw_walls();
<a name="l00504"></a>00504                         
<a name="l00505"></a>00505                         glViewport(0, 0, width, height);
<a name="l00506"></a>00506                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;velocity field&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00507"></a>00507                         draw_color_map_reference(width-panel_size+20, height-200, height-40, std::sqrt(min_vel2), std::sqrt(max_vel2), <span class="stringliteral">&quot;velocity magnitude&quot;</span>);
<a name="l00508"></a>00508                         
<a name="l00509"></a>00509                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 1) <span class="comment">// velocity magnitude</span>
<a name="l00510"></a>00510                 {
<a name="l00511"></a>00511                         <span class="keywordflow">if</span> (running)
<a name="l00512"></a>00512                         {
<a name="l00513"></a>00513                                 glMatrixMode(GL_PROJECTION);
<a name="l00514"></a>00514                                 glPushMatrix();
<a name="l00515"></a>00515                                 glLoadIdentity();
<a name="l00516"></a>00516                                 glTranslatef(-1.0, -1.0, 0.0); 
<a name="l00517"></a>00517                                 glScalef(2.0, 2.0, 1.0);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                                 glEnable(GL_TEXTURE_2D);
<a name="l00520"></a>00520                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2.0/(dim_x-1) * ibfv_sample_rate_x;
<a name="l00521"></a>00521                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2.0/(dim_y-1) * ibfv_sample_rate_y;
<a name="l00522"></a>00522                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=-ibfv_additional_pts; j&lt;ibfv_grid_dim_y-ibfv_additional_pts-1; ++j)
<a name="l00523"></a>00523                                 {
<a name="l00524"></a>00524                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y0 = j*dy-0.5;
<a name="l00525"></a>00525                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y1 = (j+1)*dy-0.5;
<a name="l00526"></a>00526                                         glBegin(GL_QUAD_STRIP);
<a name="l00527"></a>00527                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-ibfv_additional_pts; i&lt;ibfv_grid_dim_x-ibfv_additional_pts; ++i)
<a name="l00528"></a>00528                                         {
<a name="l00529"></a>00529                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x = i*dx-0.5;
<a name="l00530"></a>00530                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index0 = ((j*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00531"></a>00531                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00532"></a>00532                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index1 = (((j+1)*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00533"></a>00533                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00534"></a>00534                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x0d = x + u_data[index0]*1.0/(dim_x)*num_steps;<span class="comment">//*2.0/(dim_x-1)*ibfv_sample_rate_x;</span>
<a name="l00535"></a>00535                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y0d = y0 + v_data[index0]*1.0/(dim_y)*num_steps;<span class="comment">//(dim_y-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00536"></a>00536                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x1d = x + u_data[index1]*1.0/(dim_x)*num_steps;<span class="comment">//*ibfv_sample_rate_x;//*2.0/(dim_x-1);</span>
<a name="l00537"></a>00537                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y1d = y1 + v_data[index1]*1.0/(dim_y)*num_steps;<span class="comment">//-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00538"></a>00538                                                 glTexCoord2f(x, y0); 
<a name="l00539"></a>00539                                                 glVertex2f(x0d, y0d);
<a name="l00540"></a>00540                                                 glTexCoord2f(x, y1); 
<a name="l00541"></a>00541                                                 glVertex2f(x1d, y1d);
<a name="l00542"></a>00542                                         }
<a name="l00543"></a>00543                                         glEnd();
<a name="l00544"></a>00544                                 }
<a name="l00545"></a>00545                                 ++frame_index;
<a name="l00546"></a>00546                                 glEnable(GL_BLEND); 
<a name="l00547"></a>00547                                 glCallList(frame_index % (ibfv_num_pattern-1) + 2);
<a name="l00548"></a>00548                                 glBegin(GL_QUAD_STRIP);
<a name="l00549"></a>00549                                         glTexCoord2f(0.0,  0.0);  glVertex2f(0.0, 0.0);
<a name="l00550"></a>00550                                         glTexCoord2f(0.0,  height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(0.0, 1.0);
<a name="l00551"></a>00551                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), 0.0);  glVertex2f(1.0, 0.0);
<a name="l00552"></a>00552                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(1.0, 1.0);
<a name="l00553"></a>00553                                 glEnd();
<a name="l00554"></a>00554                                 <span class="comment">//glDisable(GL_BLEND);</span>
<a name="l00555"></a>00555                                 <span class="comment">//glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);</span>
<a name="l00556"></a>00556                                 glDisable(GL_TEXTURE_2D);
<a name="l00557"></a>00557                                 glPopMatrix();
<a name="l00558"></a>00558                         }       
<a name="l00559"></a>00559                         glBindBuffer(GL_ARRAY_BUFFER, u_vbo);
<a name="l00560"></a>00560                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), u_data, GL_DYNAMIC_DRAW);
<a name="l00561"></a>00561                         GLint location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;u&quot;</span>);
<a name="l00562"></a>00562                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00563"></a>00563                         glEnableVertexAttribArray(location);
<a name="l00564"></a>00564                         glBindBuffer(GL_ARRAY_BUFFER, v_vbo);
<a name="l00565"></a>00565                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), v_data, GL_DYNAMIC_DRAW);
<a name="l00566"></a>00566                         location = vel_mag_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;v&quot;</span>);
<a name="l00567"></a>00567                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00568"></a>00568                         glEnableVertexAttribArray(location);
<a name="l00569"></a>00569                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;max_magnitude2&quot;</span>,max_vel2);<span class="comment">//max_u*max_u*0.2f);</span>
<a name="l00570"></a>00570                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;min_magnitude2&quot;</span>,min_vel2);
<a name="l00571"></a>00571                         vel_mag_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;alpha&quot;</span>,0.1f);
<a name="l00572"></a>00572                         vel_mag_shader_ptr-&gt;activate();
<a name="l00573"></a>00573                         GL_CHECK_AND_PRINT_ERROR
<a name="l00574"></a>00574                         glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00575"></a>00575                         GL_CHECK_AND_PRINT_ERROR
<a name="l00576"></a>00576                         vel_mag_shader_ptr-&gt;deactivate();
<a name="l00577"></a>00577                         
<a name="l00578"></a>00578                         <span class="keywordflow">if</span> (running)
<a name="l00579"></a>00579                         {
<a name="l00580"></a>00580                                 glDisable(GL_BLEND);
<a name="l00581"></a>00581                                 glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);
<a name="l00582"></a>00582                         }
<a name="l00583"></a>00583                         
<a name="l00584"></a>00584                         draw_walls();
<a name="l00585"></a>00585                         
<a name="l00586"></a>00586                         glViewport(0, 0, width, height);
<a name="l00587"></a>00587                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;velocity field&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00588"></a>00588                         draw_color_map_reference(width-panel_size+20, height-200, height-40, std::sqrt(min_vel2), std::sqrt(max_vel2), <span class="stringliteral">&quot;velocity magnitude&quot;</span>);
<a name="l00589"></a>00589                 }
<a name="l00590"></a>00590                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 2) <span class="comment">// x velocity component</span>
<a name="l00591"></a>00591                 {
<a name="l00592"></a>00592                         glBindBuffer(GL_ARRAY_BUFFER, u_vbo);
<a name="l00593"></a>00593                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), u_data, GL_DYNAMIC_DRAW);
<a name="l00594"></a>00594                         GLint location = u_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00595"></a>00595                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00596"></a>00596                         glEnableVertexAttribArray(location);
<a name="l00597"></a>00597                         u_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;max_s&quot;</span>,max_u);
<a name="l00598"></a>00598                         u_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;min_s&quot;</span>,min_u);
<a name="l00599"></a>00599                         u_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;alpha&quot;</span>,1.0f);
<a name="l00600"></a>00600                         u_shader_ptr-&gt;activate();
<a name="l00601"></a>00601                         GL_CHECK_AND_PRINT_ERROR
<a name="l00602"></a>00602                         glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00603"></a>00603                         GL_CHECK_AND_PRINT_ERROR
<a name="l00604"></a>00604                         u_shader_ptr-&gt;deactivate();
<a name="l00605"></a>00605                         
<a name="l00606"></a>00606                         glViewport(0, 0, width, height);
<a name="l00607"></a>00607                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;x velocity&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00608"></a>00608                         draw_color_map_reference(width-panel_size+20, height-200, height-40, min_u, max_u, <span class="stringliteral">&quot;velocity&quot;</span>);
<a name="l00609"></a>00609                 }
<a name="l00610"></a>00610                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 3) <span class="comment">// y velocity component</span>
<a name="l00611"></a>00611                 {
<a name="l00612"></a>00612                         v_shader_ptr-&gt;activate();
<a name="l00613"></a>00613                         glBindBuffer(GL_ARRAY_BUFFER, v_vbo);
<a name="l00614"></a>00614                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), v_data, GL_DYNAMIC_DRAW);
<a name="l00615"></a>00615                         GLint location = v_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00616"></a>00616                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00617"></a>00617                         glEnableVertexAttribArray(location);
<a name="l00618"></a>00618                         v_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;max_s&quot;</span>,max_v);
<a name="l00619"></a>00619                         v_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;min_s&quot;</span>,min_v);
<a name="l00620"></a>00620                         v_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;alpha&quot;</span>,1.0f);
<a name="l00621"></a>00621                         GL_CHECK_AND_PRINT_ERROR
<a name="l00622"></a>00622                         glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00623"></a>00623                         GL_CHECK_AND_PRINT_ERROR
<a name="l00624"></a>00624                         v_shader_ptr-&gt;deactivate();
<a name="l00625"></a>00625                         
<a name="l00626"></a>00626                         draw_walls();
<a name="l00627"></a>00627                         
<a name="l00628"></a>00628                         glViewport(0, 0, width, height);
<a name="l00629"></a>00629                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;y velocity&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00630"></a>00630                         draw_color_map_reference(width-panel_size+20, height-200, height-40, min_v, max_v, <span class="stringliteral">&quot;velocity&quot;</span>);
<a name="l00631"></a>00631                 }
<a name="l00632"></a>00632                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 4) <span class="comment">// density</span>
<a name="l00633"></a>00633                 {
<a name="l00634"></a>00634                         glBindBuffer(GL_ARRAY_BUFFER, rho_vbo);
<a name="l00635"></a>00635                         glBufferData(GL_ARRAY_BUFFER, field_vbo_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), rho_data, GL_DYNAMIC_DRAW);
<a name="l00636"></a>00636                         GLint location = rho_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;s&quot;</span>);
<a name="l00637"></a>00637                         glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00638"></a>00638                         glEnableVertexAttribArray(location);
<a name="l00639"></a>00639                         rho_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;max_s&quot;</span>,max_rho);
<a name="l00640"></a>00640                         rho_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;min_s&quot;</span>,min_rho);
<a name="l00641"></a>00641                         rho_shader_ptr-&gt;set_uniform(<span class="stringliteral">&quot;alpha&quot;</span>,1.0f);
<a name="l00642"></a>00642                         rho_shader_ptr-&gt;activate();
<a name="l00643"></a>00643                         GL_CHECK_AND_PRINT_ERROR
<a name="l00644"></a>00644                         glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00645"></a>00645                         GL_CHECK_AND_PRINT_ERROR
<a name="l00646"></a>00646                         rho_shader_ptr-&gt;deactivate();
<a name="l00647"></a>00647                         
<a name="l00648"></a>00648                         draw_walls();
<a name="l00649"></a>00649                         
<a name="l00650"></a>00650                         glViewport(0, 0, width, height);
<a name="l00651"></a>00651                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;density&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00652"></a>00652                         draw_color_map_reference(width-panel_size+20, height-200, height-40, min_rho, max_rho, <span class="stringliteral">&quot;density&quot;</span>);
<a name="l00653"></a>00653                 }
<a name="l00654"></a>00654                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 5) <span class="comment">// particles</span>
<a name="l00655"></a>00655                 {
<a name="l00656"></a>00656                         <span class="keywordflow">if</span> (start_particles)
<a name="l00657"></a>00657                         {
<a name="l00658"></a>00658                                 particle_list.clear();
<a name="l00659"></a>00659                                 start_particles = <span class="keyword">false</span>;
<a name="l00660"></a>00660                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dim_x)/10;
<a name="l00661"></a>00661                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dy = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dim_y)/10;
<a name="l00662"></a>00662                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;10; ++j)
<a name="l00663"></a>00663                                 {
<a name="l00664"></a>00664                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;10; ++i)
<a name="l00665"></a>00665                                         {
<a name="l00666"></a>00666                                                 particle_list.push_back(particle(i*dx+dx/2,j*dy+dy/2));
<a name="l00667"></a>00667                                         }
<a name="l00668"></a>00668                                 }
<a name="l00669"></a>00669                         }
<a name="l00670"></a>00670                         <span class="comment">//glViewport(0, 0, width, height);</span>
<a name="l00671"></a>00671                         <span class="keywordflow">if</span> (running)
<a name="l00672"></a>00672                         {
<a name="l00673"></a>00673                                 glMatrixMode(GL_PROJECTION);
<a name="l00674"></a>00674                                 glPushMatrix();
<a name="l00675"></a>00675                                 glLoadIdentity();
<a name="l00676"></a>00676                                 glTranslatef(-1.0, -1.0, 0.0); 
<a name="l00677"></a>00677                                 glScalef(2.0, 2.0, 1.0);
<a name="l00678"></a>00678 
<a name="l00679"></a>00679                                 glEnable(GL_TEXTURE_2D);
<a name="l00680"></a>00680                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2.0/(dim_x-1) * ibfv_sample_rate_x;
<a name="l00681"></a>00681                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2.0/(dim_y-1) * ibfv_sample_rate_y;
<a name="l00682"></a>00682                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=-ibfv_additional_pts; j&lt;ibfv_grid_dim_y-ibfv_additional_pts-1; ++j)
<a name="l00683"></a>00683                                 {
<a name="l00684"></a>00684                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y0 = j*dy-0.5;
<a name="l00685"></a>00685                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y1 = (j+1)*dy-0.5;
<a name="l00686"></a>00686                                         glBegin(GL_QUAD_STRIP);
<a name="l00687"></a>00687                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-ibfv_additional_pts; i&lt;ibfv_grid_dim_x-ibfv_additional_pts; ++i)
<a name="l00688"></a>00688                                         {
<a name="l00689"></a>00689                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x = i*dx-0.5;
<a name="l00690"></a>00690                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index0 = ((j*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00691"></a>00691                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00692"></a>00692                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index1 = (((j+1)*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00693"></a>00693                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00694"></a>00694                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x0d = x - u_data[index0]*1.0/(dim_x)*num_steps;<span class="comment">//*2.0/(dim_x-1)*ibfv_sample_rate_x;</span>
<a name="l00695"></a>00695                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y0d = y0 - v_data[index0]*1.0/(dim_y)*num_steps;<span class="comment">//(dim_y-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00696"></a>00696                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x1d = x - u_data[index1]*1.0/(dim_x)*num_steps;<span class="comment">//*ibfv_sample_rate_x;//*2.0/(dim_x-1);</span>
<a name="l00697"></a>00697                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y1d = y1 - v_data[index1]*1.0/(dim_y)*num_steps;<span class="comment">//-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00698"></a>00698                                                 glTexCoord2f(x, y0); 
<a name="l00699"></a>00699                                                 glVertex2f(x0d, y0d);
<a name="l00700"></a>00700                                                 glTexCoord2f(x, y1); 
<a name="l00701"></a>00701                                                 glVertex2f(x1d, y1d);
<a name="l00702"></a>00702                                         }
<a name="l00703"></a>00703                                         glEnd();
<a name="l00704"></a>00704                                 }
<a name="l00705"></a>00705                                 glEnable(GL_BLEND); 
<a name="l00706"></a>00706                                 glCallList(1);
<a name="l00707"></a>00707                                 glBegin(GL_QUAD_STRIP);
<a name="l00708"></a>00708                                         glTexCoord2f(0.0,  0.0);  glVertex2f(0.0, 0.0);
<a name="l00709"></a>00709                                         glTexCoord2f(0.0,  height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(0.0, 1.0);
<a name="l00710"></a>00710                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), 0.0);  glVertex2f(1.0, 0.0);
<a name="l00711"></a>00711                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(1.0, 1.0);
<a name="l00712"></a>00712                                 glEnd();
<a name="l00713"></a>00713                                 <span class="comment">//glDisable(GL_BLEND);</span>
<a name="l00714"></a>00714                                 <span class="comment">//glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);</span>
<a name="l00715"></a>00715                                 glDisable(GL_TEXTURE_2D);
<a name="l00716"></a>00716                                 glPopMatrix();
<a name="l00717"></a>00717                         }       
<a name="l00718"></a>00718                         <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter=particle_list.begin(); iter!=particle_list.end(); ++iter)
<a name="l00719"></a>00719                         {
<a name="l00720"></a>00720                                 <span class="keyword">const</span> <span class="keywordtype">float</span> vx = bilinear_interpolation(u_data,iter-&gt;x,iter-&gt;y);
<a name="l00721"></a>00721                                 <span class="keyword">const</span> <span class="keywordtype">float</span> vy = bilinear_interpolation(v_data,iter-&gt;x,iter-&gt;y);
<a name="l00722"></a>00722                                 <span class="keywordflow">if</span> (running)
<a name="l00723"></a>00723                                 {
<a name="l00724"></a>00724                                         iter-&gt;x += vx*num_steps;
<a name="l00725"></a>00725                                         iter-&gt;y += vy*num_steps;
<a name="l00726"></a>00726                                         <span class="keywordflow">if</span> (periodic_x &amp;&amp; iter-&gt;x &gt;= dim_x) iter-&gt;x -= dim_x;
<a name="l00727"></a>00727                                         <span class="keywordflow">if</span> (periodic_x &amp;&amp; iter-&gt;x &lt; 0) iter-&gt;x += dim_x;
<a name="l00728"></a>00728                                         <span class="keywordflow">if</span> (periodic_y &amp;&amp; iter-&gt;y &gt;= dim_y) iter-&gt;y -= dim_y;
<a name="l00729"></a>00729                                         <span class="keywordflow">if</span> (periodic_y &amp;&amp; iter-&gt;y &lt; 0) iter-&gt;y += dim_y;
<a name="l00730"></a>00730                                 }
<a name="l00731"></a>00731                                 <span class="keywordtype">float</span> red, green, blue;
<a name="l00732"></a>00732                                 get_jet_color(std::min(std::max((vx*vx+vy*vy - min_vel2)/(max_vel2-min_vel2),0.0f),1.0f), red, green, blue);
<a name="l00733"></a>00733                                 <span class="comment">//get_jet_color(std::min((vx*vx + vy*vy) / (max_u*max_u*0.2f),1.0f), red, green, blue);</span>
<a name="l00734"></a>00734                                 glColor4f(red,green,blue,0.5f);
<a name="l00735"></a>00735                                 draw_circle((iter-&gt;x/dim_x)*(width), (iter-&gt;y/dim_y)*height, 3.0, 12);
<a name="l00736"></a>00736                         }
<a name="l00737"></a>00737                         <span class="keywordflow">if</span> (running)
<a name="l00738"></a>00738                         {
<a name="l00739"></a>00739                                 glDisable(GL_BLEND);
<a name="l00740"></a>00740                                 glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);
<a name="l00741"></a>00741                         }
<a name="l00742"></a>00742                         
<a name="l00743"></a>00743                         draw_walls();
<a name="l00744"></a>00744                         
<a name="l00745"></a>00745                         glViewport(0, 0, width, height);
<a name="l00746"></a>00746                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;particles&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00747"></a>00747                         draw_color_map_reference(width-panel_size+20, height-200, height-40, std::sqrt(min_vel2), std::sqrt(max_vel2), <span class="stringliteral">&quot;velocity magnitude&quot;</span>);
<a name="l00748"></a>00748                 }
<a name="l00749"></a>00749                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 6) <span class="comment">// &quot;vectors&quot;</span>
<a name="l00750"></a>00750                 {
<a name="l00751"></a>00751                         <span class="comment">//glViewport(0, 0, width, height);</span>
<a name="l00752"></a>00752                         <span class="comment">//if (use_ibfv &amp;&amp; running)</span>
<a name="l00753"></a>00753                         {
<a name="l00754"></a>00754                                 glMatrixMode(GL_PROJECTION);
<a name="l00755"></a>00755                                 glPushMatrix();
<a name="l00756"></a>00756                                 glLoadIdentity();
<a name="l00757"></a>00757                                 glTranslatef(-1.0, -1.0, 0.0); 
<a name="l00758"></a>00758                                 glScalef(2.0, 2.0, 1.0);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760                                 glEnable(GL_TEXTURE_2D);
<a name="l00761"></a>00761                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2.0/(dim_x-1) * ibfv_sample_rate_x;
<a name="l00762"></a>00762                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2.0/(dim_y-1) * ibfv_sample_rate_y;
<a name="l00763"></a>00763                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=-ibfv_additional_pts; j&lt;ibfv_grid_dim_y-ibfv_additional_pts-1; ++j)
<a name="l00764"></a>00764                                 {
<a name="l00765"></a>00765                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y0 = j*dy-0.5;
<a name="l00766"></a>00766                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y1 = (j+1)*dy-0.5;
<a name="l00767"></a>00767                                         glBegin(GL_QUAD_STRIP);
<a name="l00768"></a>00768                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-ibfv_additional_pts; i&lt;ibfv_grid_dim_x-ibfv_additional_pts; ++i)
<a name="l00769"></a>00769                                         {
<a name="l00770"></a>00770                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x = i*dx-0.5;
<a name="l00771"></a>00771                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index0 = ((j*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00772"></a>00772                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00773"></a>00773                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index1 = (((j+1)*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00774"></a>00774                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00775"></a>00775                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x0d = x + u_data[index0]*1.0/(dim_x)*num_steps;<span class="comment">//*2.0/(dim_x-1)*ibfv_sample_rate_x;</span>
<a name="l00776"></a>00776                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y0d = y0 + v_data[index0]*1.0/(dim_y)*num_steps;<span class="comment">//(dim_y-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00777"></a>00777                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x1d = x + u_data[index1]*1.0/(dim_x)*num_steps;<span class="comment">//*ibfv_sample_rate_x;//*2.0/(dim_x-1);</span>
<a name="l00778"></a>00778                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y1d = y1 + v_data[index1]*1.0/(dim_y)*num_steps;<span class="comment">//-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00779"></a>00779                                                 glTexCoord2f(x, y0); 
<a name="l00780"></a>00780                                                 glVertex2f(x0d, y0d);
<a name="l00781"></a>00781                                                 glTexCoord2f(x, y1); 
<a name="l00782"></a>00782                                                 glVertex2f(x1d, y1d);
<a name="l00783"></a>00783                                         }
<a name="l00784"></a>00784                                         glEnd();
<a name="l00785"></a>00785                                 }
<a name="l00786"></a>00786                                 glEnable(GL_BLEND); 
<a name="l00787"></a>00787                                 glCallList(1);
<a name="l00788"></a>00788                                 glBegin(GL_QUAD_STRIP);
<a name="l00789"></a>00789                                         glTexCoord2f(0.0,  0.0);  glVertex2f(0.0, 0.0);
<a name="l00790"></a>00790                                         glTexCoord2f(0.0,  height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(0.0, 1.0);
<a name="l00791"></a>00791                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), 0.0);  glVertex2f(1.0, 0.0);
<a name="l00792"></a>00792                                         glTexCoord2f((width-panel_size)/(ibfv_scale*ibfv_texture_dim), height/(ibfv_scale*ibfv_texture_dim)); glVertex2f(1.0, 1.0);
<a name="l00793"></a>00793                                 glEnd();
<a name="l00794"></a>00794                                 <span class="comment">//glDisable(GL_BLEND);</span>
<a name="l00795"></a>00795                                 <span class="comment">//glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);</span>
<a name="l00796"></a>00796                                 glDisable(GL_TEXTURE_2D);
<a name="l00797"></a>00797                                 glPopMatrix();
<a name="l00798"></a>00798                         }       
<a name="l00799"></a>00799                         <span class="keywordtype">int</span> nvx = (width-panel_size)/30;
<a name="l00800"></a>00800                         <span class="keywordtype">int</span> nvy = (height)/30;
<a name="l00801"></a>00801                         <span class="keyword">const</span> <span class="keywordtype">float</span> dx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dim_x)/nvx;
<a name="l00802"></a>00802                         <span class="keyword">const</span> <span class="keywordtype">float</span> dy = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dim_y)/nvy;
<a name="l00803"></a>00803                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;nvy; ++j)
<a name="l00804"></a>00804                         {
<a name="l00805"></a>00805                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nvx; ++i)
<a name="l00806"></a>00806                                 {
<a name="l00807"></a>00807                                         <span class="keyword">const</span> <span class="keywordtype">float</span> x = (i*dx+dx/2);
<a name="l00808"></a>00808                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y = (j*dy+dy/2);
<a name="l00809"></a>00809                                         <span class="keyword">const</span> <span class="keywordtype">float</span> xs = (x/dim_x)*(width);
<a name="l00810"></a>00810                                         <span class="keyword">const</span> <span class="keywordtype">float</span> ys = (y/dim_y)*height;
<a name="l00811"></a>00811                                         <span class="keyword">const</span> <span class="keywordtype">float</span> vx = bilinear_interpolation(u_data,x,y);
<a name="l00812"></a>00812                                         <span class="keyword">const</span> <span class="keywordtype">float</span> vy = bilinear_interpolation(v_data,x,y);
<a name="l00813"></a>00813                                         <span class="keywordtype">float</span> red, green, blue;
<a name="l00814"></a>00814                                         get_jet_color(std::min(std::max((vx*vx+vy*vy - min_vel2)/(max_vel2-min_vel2),0.0f),1.0f), red, green, blue);
<a name="l00815"></a>00815                                         <span class="comment">//get_jet_color(std::min((vx*vx + vy*vy) / (max_u*max_u*0.2f),1.0f), red, green, blue);</span>
<a name="l00816"></a>00816                                         glColor4f(red,green,blue,std::min(std::max((vx*vx+vy*vy - min_vel2)/(max_vel2-min_vel2),0.0f),1.0f));
<a name="l00817"></a>00817                                         draw_circle(xs,ys, 3.0, 12);
<a name="l00818"></a>00818                                 }
<a name="l00819"></a>00819                         }
<a name="l00820"></a>00820                         <span class="comment">//if (use_ibfv &amp;&amp; running)</span>
<a name="l00821"></a>00821                         {
<a name="l00822"></a>00822                                 glDisable(GL_BLEND);
<a name="l00823"></a>00823                                 glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);
<a name="l00824"></a>00824                         }
<a name="l00825"></a>00825                         
<a name="l00826"></a>00826                         draw_walls();
<a name="l00827"></a>00827                         
<a name="l00828"></a>00828                         glViewport(0, 0, width, height);
<a name="l00829"></a>00829                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;velocity vectors&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00830"></a>00830                         draw_color_map_reference(width-panel_size+20, height-200, height-40, std::sqrt(min_vel2), std::sqrt(max_vel2), <span class="stringliteral">&quot;velocity magnitude&quot;</span>);
<a name="l00831"></a>00831                 }
<a name="l00832"></a>00832                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == 7) <span class="comment">// time line</span>
<a name="l00833"></a>00833                 {
<a name="l00834"></a>00834                         <span class="keywordflow">if</span> (running &amp;&amp; start_timeline)
<a name="l00835"></a>00835                         {
<a name="l00836"></a>00836                                 start_timeline = <span class="keyword">false</span>;
<a name="l00837"></a>00837                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=40; i&lt;width-40; i+=90)
<a name="l00838"></a>00838                                 {
<a name="l00839"></a>00839                                         <span class="keywordtype">float</span> red0(1), green0(0), blue0(0);
<a name="l00840"></a>00840                                         <span class="keywordtype">float</span> red1(0), green1(0), blue1(1);
<a name="l00841"></a>00841                                         glBegin(GL_QUAD_STRIP);
<a name="l00842"></a>00842                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;height+30; j+=30)
<a name="l00843"></a>00843                                         {
<a name="l00844"></a>00844                                                 glColor4f(red0,green0,blue0,1.0f);
<a name="l00845"></a>00845                                                 glVertex2i(i-10,j);
<a name="l00846"></a>00846                                                 glVertex2i(i+10,j);
<a name="l00847"></a>00847                                                 std::swap(red0,red1);
<a name="l00848"></a>00848                                                 std::swap(green0,green1);
<a name="l00849"></a>00849                                                 std::swap(blue0,blue1);
<a name="l00850"></a>00850                                         }
<a name="l00851"></a>00851                                         glEnd();
<a name="l00852"></a>00852                                 }
<a name="l00853"></a>00853                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=40; j&lt;height-40; j+=90)
<a name="l00854"></a>00854                                 {
<a name="l00855"></a>00855                                         <span class="keywordtype">float</span> red0(1), green0(0), blue0(0);
<a name="l00856"></a>00856                                         <span class="keywordtype">float</span> red1(0), green1(0), blue1(1);
<a name="l00857"></a>00857                                         glBegin(GL_QUAD_STRIP);
<a name="l00858"></a>00858                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;width+30; i+=30)
<a name="l00859"></a>00859                                         {
<a name="l00860"></a>00860                                                 glColor4f(red0,green0,blue0,1.0f);
<a name="l00861"></a>00861                                                 glVertex2i(i,j-10);    glVertex2i(i,j+10);
<a name="l00862"></a>00862                                                 std::swap(red0,red1);
<a name="l00863"></a>00863                                                 std::swap(green0,green1);
<a name="l00864"></a>00864                                                 std::swap(blue0,blue1);
<a name="l00865"></a>00865                                         }
<a name="l00866"></a>00866                                         glEnd();
<a name="l00867"></a>00867                                 }
<a name="l00868"></a>00868                                 glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);
<a name="l00869"></a>00869                         }
<a name="l00870"></a>00870                         <span class="keywordflow">if</span> (running)
<a name="l00871"></a>00871                         {
<a name="l00872"></a>00872                                 glMatrixMode(GL_PROJECTION);
<a name="l00873"></a>00873                                 glPushMatrix();
<a name="l00874"></a>00874                                 glLoadIdentity();
<a name="l00875"></a>00875                                 glTranslatef(-1.0, -1.0, 0.0); 
<a name="l00876"></a>00876                                 glScalef(2.0, 2.0, 1.0);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878                                 glEnable(GL_TEXTURE_2D);
<a name="l00879"></a>00879                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dx = 2.0/(dim_x-1) * ibfv_sample_rate_x;
<a name="l00880"></a>00880                                 <span class="keyword">const</span> <span class="keywordtype">float</span> dy = 2.0/(dim_y-1) * ibfv_sample_rate_y;
<a name="l00881"></a>00881                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=-ibfv_additional_pts; j&lt;ibfv_grid_dim_y-ibfv_additional_pts-1; ++j)
<a name="l00882"></a>00882                                 {
<a name="l00883"></a>00883                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y0 = j*dy-0.5;
<a name="l00884"></a>00884                                         <span class="keyword">const</span> <span class="keywordtype">float</span> y1 = (j+1)*dy-0.5;
<a name="l00885"></a>00885                                         glBegin(GL_QUAD_STRIP);
<a name="l00886"></a>00886                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-ibfv_additional_pts; i&lt;ibfv_grid_dim_x-ibfv_additional_pts; ++i)
<a name="l00887"></a>00887                                         {
<a name="l00888"></a>00888                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x = i*dx-0.5;
<a name="l00889"></a>00889                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index0 = ((j*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00890"></a>00890                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00891"></a>00891                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index1 = (((j+1)*ibfv_sample_rate_y+real_dim_y) % real_dim_y)*real_dim_x + 
<a name="l00892"></a>00892                                                                                           ((i*ibfv_sample_rate_x+real_dim_x) % real_dim_x);
<a name="l00893"></a>00893                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x0d = x + u_data[index0]*1.0/(dim_x)*num_steps;<span class="comment">//*2.0/(dim_x-1)*ibfv_sample_rate_x;</span>
<a name="l00894"></a>00894                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y0d = y0 + v_data[index0]*1.0/(dim_y)*num_steps;<span class="comment">//(dim_y-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00895"></a>00895                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> x1d = x + u_data[index1]*1.0/(dim_x)*num_steps;<span class="comment">//*ibfv_sample_rate_x;//*2.0/(dim_x-1);</span>
<a name="l00896"></a>00896                                                 <span class="keyword">const</span> <span class="keywordtype">float</span> y1d = y1 + v_data[index1]*1.0/(dim_y)*num_steps;<span class="comment">//-1)*ibfv_sample_rate_y;//*2.0/(dim_y-1);</span>
<a name="l00897"></a>00897                                                 glTexCoord2f(x, y0); 
<a name="l00898"></a>00898                                                 glVertex2f(x0d, y0d);
<a name="l00899"></a>00899                                                 glTexCoord2f(x, y1); 
<a name="l00900"></a>00900                                                 glVertex2f(x1d, y1d);
<a name="l00901"></a>00901                                         }
<a name="l00902"></a>00902                                         glEnd();
<a name="l00903"></a>00903                                 }
<a name="l00904"></a>00904                                 glDisable(GL_TEXTURE_2D);
<a name="l00905"></a>00905                                 glPopMatrix();
<a name="l00906"></a>00906                                 glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, width-panel_size, height, 0);
<a name="l00907"></a>00907                         }
<a name="l00908"></a>00908                         
<a name="l00909"></a>00909                         draw_walls();
<a name="l00910"></a>00910                         
<a name="l00911"></a>00911                         glViewport(0, 0, width, height);
<a name="l00912"></a>00912                         screen_text(width-panel_size+20,height-20,1,1,1,<span class="stringliteral">&quot;time lines&quot;</span>,GLUT_BITMAP_HELVETICA_18);
<a name="l00913"></a>00913                 }
<a name="l00914"></a>00914                 
<a name="l00915"></a>00915                 
<a name="l00916"></a>00916                 glutSwapBuffers();
<a name="l00917"></a>00917         }
<a name="l00918"></a>00918         
<a name="l00919"></a>00919         <span class="keywordtype">void</span> draw_walls()
<a name="l00920"></a>00920         {
<a name="l00921"></a>00921                 glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
<a name="l00922"></a>00922                 glEnable(GL_BLEND);
<a name="l00923"></a>00923                 glBindBuffer(GL_ARRAY_BUFFER, wall_vbo);
<a name="l00924"></a>00924                 <span class="comment">//glBufferData(GL_ARRAY_BUFFER, field_vbo_size*sizeof(float), wall_data, GL_STATIC_DRAW);</span>
<a name="l00925"></a>00925                 GLint location = wall_shader_ptr-&gt;get_attribute_location(<span class="stringliteral">&quot;wall&quot;</span>);
<a name="l00926"></a>00926                 glVertexAttribPointer(location, 1, GL_FLOAT, GL_FALSE, 0, (GLvoid *) 0);
<a name="l00927"></a>00927                 glEnableVertexAttribArray(location);
<a name="l00928"></a>00928                 wall_shader_ptr-&gt;activate();
<a name="l00929"></a>00929                 GL_CHECK_AND_PRINT_ERROR
<a name="l00930"></a>00930                 glDrawElements(GL_QUADS, simulation_grid_ibo_size, GL_UNSIGNED_INT, 0);
<a name="l00931"></a>00931                 GL_CHECK_AND_PRINT_ERROR
<a name="l00932"></a>00932                 wall_shader_ptr-&gt;deactivate();
<a name="l00933"></a>00933                 glDisable(GL_BLEND);
<a name="l00934"></a>00934                 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
<a name="l00935"></a>00935         }
<a name="l00936"></a>00936         
<a name="l00937"></a>00937         <span class="keywordtype">void</span> idle() { }
<a name="l00938"></a>00938         
<a name="l00939"></a>00939         <span class="keywordtype">void</span> keybord(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00940"></a>00940         {
<a name="l00941"></a>00941                 <span class="keywordflow">if</span>(key == 32) <span class="comment">// space</span>
<a name="l00942"></a>00942                 {
<a name="l00943"></a>00943                         <span class="keywordflow">if</span> (running) running = <span class="keyword">false</span>;
<a name="l00944"></a>00944                         <span class="keywordflow">else</span> running = <span class="keyword">true</span>;
<a name="l00945"></a>00945                 } 
<a name="l00946"></a>00946                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key == 109) <span class="comment">// m</span>
<a name="l00947"></a>00947                 {
<a name="l00948"></a>00948                         mode = (mode + 1) % num_modes;
<a name="l00949"></a>00949                         <span class="keywordflow">if</span> (mode == 5) start_particles = <span class="keyword">true</span>;
<a name="l00950"></a>00950                         <span class="keywordflow">if</span> (mode == 7) start_timeline = <span class="keyword">true</span>;
<a name="l00951"></a>00951                 }
<a name="l00952"></a>00952                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key == 114) <span class="comment">// r</span>
<a name="l00953"></a>00953                 {
<a name="l00954"></a>00954                         <span class="keywordflow">if</span> (mode == 7) start_timeline = <span class="keyword">true</span>;
<a name="l00955"></a>00955                 }
<a name="l00956"></a>00956                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key == 115) <span class="comment">// s</span>
<a name="l00957"></a>00957                 {
<a name="l00958"></a>00958                         std::stringstream strstream;
<a name="l00959"></a>00959                         strstream &lt;&lt; <span class="stringliteral">&quot;LB2D_&quot;</span> &lt;&lt; std::setw(4) &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; picture_index++ &lt;&lt; <span class="stringliteral">&quot;.bmp&quot;</span>;
<a name="l00960"></a>00960                         saveFrameBuffer(strstream.str());
<a name="l00961"></a>00961                 }
<a name="l00962"></a>00962         }
<a name="l00963"></a>00963         
<a name="l00964"></a>00964         <span class="keywordtype">void</span> motion(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00965"></a>00965         {
<a name="l00966"></a>00966                 
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968         
<a name="l00969"></a>00969         <span class="keywordtype">void</span> mouse(<span class="keywordtype">int</span> button, <span class="keywordtype">int</span> state, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00970"></a>00970         {
<a name="l00971"></a>00971                 <span class="keywordflow">if</span> (mode == 5 &amp;&amp; button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_UP &amp;&amp; x &lt; width-panel_size)
<a name="l00972"></a>00972                 {
<a name="l00973"></a>00973                         particle_list.push_back(particle((static_cast&lt;float&gt;(x)/(width-panel_size))*dim_x, (static_cast&lt;float&gt;(height-y)/height)*dim_y ));
<a name="l00974"></a>00974                 }
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976         
<a name="l00977"></a>00977         <span class="keywordtype">void</span> draw_color_map_reference(<span class="keywordtype">int</span> x_min, <span class="keywordtype">int</span> y_min, <span class="keywordtype">int</span> y_max, <span class="keywordtype">float</span> min_value, <span class="keywordtype">float</span> max_value, std::string title) 
<a name="l00978"></a>00978         {
<a name="l00979"></a>00979                 <span class="keywordtype">int</span> x_max = x_min+30;
<a name="l00980"></a>00980                 glBegin(GL_QUAD_STRIP);
<a name="l00981"></a>00981                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y_min+30; j&lt;y_max+1-18; ++j)
<a name="l00982"></a>00982                 {
<a name="l00983"></a>00983                         <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = (<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(j)-y_min-30) / (y_max+1-18-y_min-30);
<a name="l00984"></a>00984                         <span class="keywordtype">float</span> red,blue,green;
<a name="l00985"></a>00985                         get_jet_color(tmp,red,green,blue);
<a name="l00986"></a>00986                         glColor4f(red,green,blue,1.0);
<a name="l00987"></a>00987                         glVertex2i(x_min, j);
<a name="l00988"></a>00988                         glVertex2i(x_max, j);
<a name="l00989"></a>00989                 }
<a name="l00990"></a>00990                 glEnd();
<a name="l00991"></a>00991                 screen_text(x_min, y_min, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;min:&quot;</span>);
<a name="l00992"></a>00992                 screen_text(x_max+10, y_min, 1.0, 1.0, 1.0, std::to_string(min_value));
<a name="l00993"></a>00993                 screen_text(x_min, y_min+15, 1.0, 1.0, 1.0, <span class="stringliteral">&quot;max:&quot;</span>);
<a name="l00994"></a>00994                 screen_text(x_max+10, y_min+15, 1.0, 1.0, 1.0, std::to_string(max_value));
<a name="l00995"></a>00995                 screen_text(x_min, y_max-12, 1.0, 1.0, 1.0, title);
<a name="l00996"></a>00996         }
<a name="l00997"></a>00997         
<a name="l00998"></a>00998         <span class="keywordtype">void</span> get_jet_color(<span class="keywordtype">float</span> value, <span class="keywordtype">float</span>&amp; red, <span class="keywordtype">float</span>&amp; green, <span class="keywordtype">float</span>&amp; blue) 
<a name="l00999"></a>00999         {
<a name="l01000"></a>01000                 <span class="keyword">const</span> <span class="keywordtype">float</span> four_value = 4 * value;
<a name="l01001"></a>01001                 red   = std::max(std::min(std::min(four_value - 1.5f, -four_value + 4.5f),1.0f),0.0f);
<a name="l01002"></a>01002                 green = std::max(std::min(std::min(four_value - 0.5f, -four_value + 3.5f),1.0f),0.0f);
<a name="l01003"></a>01003                 blue  = std::max(std::min(std::min(four_value + 0.5f, -four_value + 2.5f),1.0f),0.0f);
<a name="l01004"></a>01004         }
<a name="l01005"></a>01005         
<a name="l01006"></a>01006         <span class="keywordtype">void</span> draw_circle(<span class="keywordtype">float</span> cx, <span class="keywordtype">float</span> cy, <span class="keywordtype">float</span> r, <span class="keywordtype">int</span> num_segments) 
<a name="l01007"></a>01007         { 
<a name="l01008"></a>01008                 glBegin(GL_POLYGON); 
<a name="l01009"></a>01009                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ii = 0; ii &lt; num_segments; ii++) 
<a name="l01010"></a>01010                 { 
<a name="l01011"></a>01011                         <span class="keywordtype">float</span> theta = 2.0f * 3.1415926f * float(ii) / float(num_segments);<span class="comment">//get the current angle </span>
<a name="l01012"></a>01012 
<a name="l01013"></a>01013                         <span class="keywordtype">float</span> x = r * std::cos(theta);<span class="comment">//calculate the x component </span>
<a name="l01014"></a>01014                         <span class="keywordtype">float</span> y = r * std::sin(theta);<span class="comment">//calculate the y component </span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016                         glVertex2f(x + cx, y + cy);<span class="comment">//output vertex </span>
<a name="l01017"></a>01017 
<a name="l01018"></a>01018                 } 
<a name="l01019"></a>01019                 glEnd(); 
<a name="l01020"></a>01020         }
<a name="l01021"></a>01021         
<a name="l01022"></a>01022         <span class="keywordtype">float</span> bilinear_interpolation(<span class="keywordtype">float</span>* field, <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)
<a name="l01023"></a>01023         {
<a name="l01024"></a>01024                 <span class="comment">//std::cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot; -&gt; &quot;;</span>
<a name="l01025"></a>01025                 <span class="keywordtype">int</span> xl(x); <span class="keywordflow">if</span> (xl&lt;0) --xl;
<a name="l01026"></a>01026                 <span class="keywordtype">int</span> yl(y); <span class="keywordflow">if</span> (yl&lt;0) --yl;
<a name="l01027"></a>01027                 <span class="keywordtype">int</span> xh(xl+1);
<a name="l01028"></a>01028                 <span class="keywordtype">int</span> yh(yl+1);
<a name="l01029"></a>01029                 <span class="keyword">const</span> <span class="keywordtype">float</span> ax = (x-xl);
<a name="l01030"></a>01030                 <span class="keyword">const</span> <span class="keywordtype">float</span> ay = (y-yl);
<a name="l01031"></a>01031                 <span class="comment">//std::cout &lt;&lt; &quot;(&quot; &lt;&lt; xl &lt;&lt; &quot;,&quot; &lt;&lt; yl &lt;&lt; &quot; - &quot; &lt;&lt; xh &lt;&lt; &quot;,&quot; &lt;&lt; yh &lt;&lt; &quot;), ax=&quot; &lt;&lt; ax &lt;&lt; &quot;, ay=&quot; &lt;&lt; ay &lt;&lt; std::endl;</span>
<a name="l01032"></a>01032                 <span class="keywordflow">if</span> (periodic_x)
<a name="l01033"></a>01033                 {
<a name="l01034"></a>01034                         xl = (xl+dim_x) % dim_x;
<a name="l01035"></a>01035                         xh = (xh+dim_x) % dim_x;
<a name="l01036"></a>01036                 }
<a name="l01037"></a>01037                 <span class="keywordflow">else</span> 
<a name="l01038"></a>01038                 {
<a name="l01039"></a>01039                         <span class="keywordflow">if</span> (xl &gt;= dim_x) xl = dim_x-1; <span class="keywordflow">if</span>(xl &lt; 0) xl=0;
<a name="l01040"></a>01040                         <span class="keywordflow">if</span> (xh &gt;= dim_x) xh = dim_x-1; <span class="keywordflow">if</span>(xh &lt; 0) xh=0;
<a name="l01041"></a>01041                 }
<a name="l01042"></a>01042                 <span class="keywordflow">if</span> (periodic_y)
<a name="l01043"></a>01043                 {
<a name="l01044"></a>01044                         yl = (yl+dim_y) % dim_y;
<a name="l01045"></a>01045                         yh = (yh+dim_y) % dim_y;
<a name="l01046"></a>01046                 }
<a name="l01047"></a>01047                 <span class="keywordflow">else</span> 
<a name="l01048"></a>01048                 {
<a name="l01049"></a>01049                         <span class="keywordflow">if</span> (yl &gt;= dim_y) yl = dim_y-1; <span class="keywordflow">if</span>(yl &lt; 0) yl=0;
<a name="l01050"></a>01050                         <span class="keywordflow">if</span> (yh &gt;= dim_y) yh = dim_y-1; <span class="keywordflow">if</span>(yh &lt; 0) yh=0;
<a name="l01051"></a>01051                 }
<a name="l01052"></a>01052                 <span class="keyword">const</span> <span class="keywordtype">float</span> v0 = (1.0-ax)*field[(yl+buffer_size)*real_dim_x + xl + buffer_size] + ax*field[(yl+buffer_size)*real_dim_x + xh + buffer_size];
<a name="l01053"></a>01053                 <span class="keyword">const</span> <span class="keywordtype">float</span> v1 = (1.0-ax)*field[(yh+buffer_size)*real_dim_x + xl + buffer_size] + ax*field[(yh+buffer_size)*real_dim_x + xh + buffer_size];
<a name="l01054"></a>01054                 <span class="keywordflow">return</span> (1.0-ay)*v0 + ay*v1;
<a name="l01055"></a>01055         }
<a name="l01056"></a>01056         
<a name="l01057"></a>01057         <span class="keywordtype">void</span> screen_text(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b, std::string str, <span class="keywordtype">void</span>* font = GLUT_BITMAP_HELVETICA_12)
<a name="l01058"></a>01058         {
<a name="l01059"></a>01059                 <span class="comment">/*GLUT_BITMAP_8_BY_13</span>
<a name="l01060"></a>01060 <span class="comment">                GLUT_BITMAP_9_BY_15</span>
<a name="l01061"></a>01061 <span class="comment">                GLUT_BITMAP_TIMES_ROMAN_10</span>
<a name="l01062"></a>01062 <span class="comment">                GLUT_BITMAP_TIMES_ROMAN_24</span>
<a name="l01063"></a>01063 <span class="comment">                GLUT_BITMAP_HELVETICA_10</span>
<a name="l01064"></a>01064 <span class="comment">                GLUT_BITMAP_HELVETICA_12</span>
<a name="l01065"></a>01065 <span class="comment">                GLUT_BITMAP_HELVETICA_18*/</span>
<a name="l01066"></a>01066                 glColor3f( r, g, b );
<a name="l01067"></a>01067                 glRasterPos2f(x, y);
<a name="l01068"></a>01068                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;str.size(); ++i) 
<a name="l01069"></a>01069                 {
<a name="l01070"></a>01070                         glutBitmapCharacter(font, str[i]);
<a name="l01071"></a>01071                 }
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073         
<a name="l01074"></a>01074         <span class="keywordtype">void</span> print_usage()
<a name="l01075"></a>01075         {
<a name="l01076"></a>01076                 std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01077"></a>01077                 &lt;&lt; <span class="stringliteral">&quot;visualization usage\n&quot;</span>
<a name="l01078"></a>01078                 &lt;&lt; <span class="stringliteral">&quot;-------------------\n&quot;</span>
<a name="l01079"></a>01079                 &lt;&lt; <span class="stringliteral">&quot;exit:             &lt;esc&gt;\n&quot;</span>
<a name="l01080"></a>01080                 &lt;&lt; <span class="stringliteral">&quot;start simulation: &lt;space&gt;\n&quot;</span>
<a name="l01081"></a>01081                 &lt;&lt; <span class="stringliteral">&quot;switch mode:      &lt;m&gt;\n&quot;</span>
<a name="l01082"></a>01082                 &lt;&lt; <span class="stringliteral">&quot;save screenshot:  &lt;s&gt;\n&quot;</span>;
<a name="l01083"></a>01083                 std::cout &lt;&lt; <span class="stringliteral">&quot;\n- in particle mode use mouse to create particles\n- in time line mode use &lt;r&gt; to restart\n&quot;</span>;
<a name="l01084"></a>01084         }
<a name="l01085"></a>01085         
<a name="l01086"></a>01086         <span class="keywordtype">void</span> saveFrameBuffer(std::string outfile) 
<a name="l01087"></a>01087         {
<a name="l01088"></a>01088                 std::vector&lt;unsigned char&gt; image(width*height*4);
<a name="l01089"></a>01089                 glPixelStorei(GL_PACK_ALIGNMENT, 1);
<a name="l01090"></a>01090                 glReadPixels(0,0,width,height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, &amp;image[0]);
<a name="l01091"></a>01091                 BMP bmp;
<a name="l01092"></a>01092                 bmp.SetSize(width, height);
<a name="l01093"></a>01093                 bmp.SetBitDepth(32);
<a name="l01094"></a>01094                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;bmp.TellHeight(); ++j) 
<a name="l01095"></a>01095                 {
<a name="l01096"></a>01096                         bmp.Read32bitRow(&amp;image[j*width*4], width*4, bmp.TellHeight()-j-1);
<a name="l01097"></a>01097                 }
<a name="l01098"></a>01098                 bmp.WriteToFile(outfile.c_str());
<a name="l01099"></a>01099         }
<a name="l01100"></a>01100         
<a name="l01101"></a>01101 <span class="keyword">private</span>: <span class="comment">// ibfv</span>
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordtype">void</span> make_patterns()
<a name="l01104"></a>01104         {
<a name="l01105"></a>01105                 <span class="keywordtype">int</span> lut[256];
<a name="l01106"></a>01106                 <span class="keywordtype">int</span> phase[ibfv_texture_dim][ibfv_texture_dim];
<a name="l01107"></a>01107                 GLubyte pat[ibfv_texture_dim][ibfv_texture_dim][4];
<a name="l01108"></a>01108                 <span class="keywordtype">int</span> i, j, k, t;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110                 <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++) lut[i] = i &lt; 127 ? 0 : 255;
<a name="l01111"></a>01111                 <span class="keywordflow">for</span> (i = 0; i &lt; ibfv_texture_dim; i++)
<a name="l01112"></a>01112                         <span class="keywordflow">for</span> (j = 0; j &lt; ibfv_texture_dim; j++) phase[i][j] = std::rand() % 256; 
<a name="l01113"></a>01113 
<a name="l01114"></a>01114                 <span class="keywordflow">for</span> (k = 0; k &lt; ibfv_num_pattern; k++) 
<a name="l01115"></a>01115                 {
<a name="l01116"></a>01116                         t = k*256/ibfv_num_pattern;
<a name="l01117"></a>01117                         <span class="keywordflow">for</span> (i = 0; i &lt; ibfv_texture_dim; i++) 
<a name="l01118"></a>01118                                 <span class="keywordflow">for</span> (j = 0; j &lt; ibfv_texture_dim; j++) 
<a name="l01119"></a>01119                                 {
<a name="l01120"></a>01120                                         <span class="keywordflow">if</span> (k==0)
<a name="l01121"></a>01121                                         {
<a name="l01122"></a>01122                                                 pat[i][j][0] =
<a name="l01123"></a>01123                                                 pat[i][j][1] =
<a name="l01124"></a>01124                                                 pat[i][j][2] = 0;
<a name="l01125"></a>01125                                                 pat[i][j][3] = ibfv_alpha;
<a name="l01126"></a>01126                                         }
<a name="l01127"></a>01127                                         <span class="keywordflow">else</span>
<a name="l01128"></a>01128                                         {
<a name="l01129"></a>01129                                                 pat[i][j][0] =
<a name="l01130"></a>01130                                                 pat[i][j][1] =
<a name="l01131"></a>01131                                                 pat[i][j][2] = lut[(t + phase[i][j]) % 255];
<a name="l01132"></a>01132                                                 pat[i][j][3] = ibfv_alpha;
<a name="l01133"></a>01133                                         }
<a name="l01134"></a>01134                                 }
<a name="l01135"></a>01135                         glNewList(k + 1, GL_COMPILE);
<a name="l01136"></a>01136                                 glTexImage2D(GL_TEXTURE_2D, 0, 4, ibfv_texture_dim, ibfv_texture_dim, 0, GL_RGBA, GL_UNSIGNED_BYTE, pat);
<a name="l01137"></a>01137                         glEndList();
<a name="l01138"></a>01138                 }
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140         
<a name="l01141"></a>01141 <span class="keyword">private</span>: <span class="comment">// impl</span>
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="preprocessor">        #pragma pack(push, 1)</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>        <span class="comment">// A vertex containing only a position value</span>
<a name="l01145"></a>01145         <span class="keyword">struct </span>vertex
<a name="l01146"></a>01146         {
<a name="l01147"></a>01147                 vertex() {}
<a name="l01148"></a>01148                 vertex(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z) : x(x), y(y), z(z) {}
<a name="l01149"></a>01149                 <span class="keywordtype">float</span> x, y, z;
<a name="l01150"></a>01150         };
<a name="l01151"></a>01151 <span class="preprocessor">        #pragma pack(pop)</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span>
<a name="l01153"></a>01153         <span class="keyword">struct </span>particle
<a name="l01154"></a>01154         {
<a name="l01155"></a>01155                 particle(){}
<a name="l01156"></a>01156                 particle(<span class="keywordtype">float</span> _x, <span class="keywordtype">float</span> _y) : x(_x), y(_y) {}
<a name="l01157"></a>01157                 <span class="keywordtype">float</span> x;
<a name="l01158"></a>01158                 <span class="keywordtype">float</span> y;
<a name="l01159"></a>01159         };
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 <span class="keyword">private</span>: <span class="comment">// members</span>
<a name="l01162"></a>01162 
<a name="l01163"></a>01163         <span class="keyword">static</span> std::unique_ptr&lt;visualization&gt; vis;
<a name="l01164"></a>01164         <span class="comment">// window properties</span>
<a name="l01165"></a>01165         <span class="keyword">const</span> <span class="keywordtype">int</span> panel_size;
<a name="l01166"></a>01166         <span class="keywordtype">int</span> width, height;
<a name="l01167"></a>01167         <span class="comment">// pointer to simulation</span>
<a name="l01168"></a>01168         simulation* sim;
<a name="l01169"></a>01169         <span class="comment">// simulation properties</span>
<a name="l01170"></a>01170         <span class="keyword">const</span> <span class="keywordtype">int</span> dim_x;
<a name="l01171"></a>01171         <span class="keyword">const</span> <span class="keywordtype">int</span> dim_y;
<a name="l01172"></a>01172         <span class="keyword">const</span> <span class="keywordtype">int</span> buffer_size;
<a name="l01173"></a>01173         <span class="keyword">const</span> <span class="keywordtype">int</span> real_dim_x;
<a name="l01174"></a>01174         <span class="keyword">const</span> <span class="keywordtype">int</span> real_dim_y;
<a name="l01175"></a>01175         <span class="keyword">const</span> <span class="keywordtype">bool</span> periodic_x;
<a name="l01176"></a>01176         <span class="keyword">const</span> <span class="keywordtype">bool</span> periodic_y;
<a name="l01177"></a>01177         <span class="comment">// if simulation does not use floats -&gt; cast every time</span>
<a name="l01178"></a>01178         <span class="keyword">const</span> <span class="keywordtype">bool</span> float_cast;
<a name="l01179"></a>01179         std::vector&lt;float&gt; rho_data_cast;
<a name="l01180"></a>01180         std::vector&lt;float&gt; u_data_cast;
<a name="l01181"></a>01181         std::vector&lt;float&gt; v_data_cast;
<a name="l01182"></a>01182         <span class="comment">// wall container</span>
<a name="l01183"></a>01183         std::vector&lt;float&gt; wall;
<a name="l01184"></a>01184         <span class="comment">// data pointers</span>
<a name="l01185"></a>01185         <span class="keywordtype">float</span>* rho_data;
<a name="l01186"></a>01186         <span class="keywordtype">float</span>* u_data;
<a name="l01187"></a>01187         <span class="keywordtype">float</span>* v_data;
<a name="l01188"></a>01188         <span class="keywordtype">float</span>* wall_data;
<a name="l01189"></a>01189         <span class="comment">// opacity value for drawing</span>
<a name="l01190"></a>01190         <span class="keywordtype">float</span> alpha0;
<a name="l01191"></a>01191         <span class="comment">// ibfv params</span>
<a name="l01192"></a>01192         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_alpha;
<a name="l01193"></a>01193         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_texture_dim;
<a name="l01194"></a>01194         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_sample_rate_x;
<a name="l01195"></a>01195         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_sample_rate_y;
<a name="l01196"></a>01196         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_additional_pts;
<a name="l01197"></a>01197         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_grid_dim_x;
<a name="l01198"></a>01198         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_grid_dim_y;
<a name="l01199"></a>01199         <span class="keyword">const</span> <span class="keywordtype">float</span> ibfv_scale;
<a name="l01200"></a>01200         <span class="keyword">const</span> <span class="keywordtype">int</span> ibfv_num_pattern;
<a name="l01201"></a>01201         <span class="keywordtype">int</span> frame_index;
<a name="l01202"></a>01202         std::vector&lt;float&gt; ibfv_u_data;
<a name="l01203"></a>01203         std::vector&lt;float&gt; ibfv_v_data;
<a name="l01204"></a>01204         std::vector&lt;unsigned int&gt; ibfv_x_index_lookup;
<a name="l01205"></a>01205         std::vector&lt;unsigned int&gt; ibfv_y_index_lookup;
<a name="l01206"></a>01206         <span class="comment">// opengl buffers (location and sizes)</span>
<a name="l01207"></a>01207         GLuint simulation_grid_vbo;
<a name="l01208"></a>01208         <span class="keywordtype">int</span> simulation_grid_vbo_size;
<a name="l01209"></a>01209         GLuint simulation_grid_ibo;
<a name="l01210"></a>01210         <span class="keywordtype">int</span> simulation_grid_ibo_size;
<a name="l01211"></a>01211         GLuint rho_vbo;
<a name="l01212"></a>01212         GLuint u_vbo;
<a name="l01213"></a>01213         GLuint v_vbo;
<a name="l01214"></a>01214         GLuint wall_vbo;
<a name="l01215"></a>01215         <span class="keywordtype">int</span> field_vbo_size;
<a name="l01216"></a>01216         <span class="comment">// holder for shader objects</span>
<a name="l01217"></a>01217         std::unique_ptr&lt;shader&gt; vel_mag_shader_ptr;
<a name="l01218"></a>01218         std::unique_ptr&lt;shader&gt; rho_shader_ptr;
<a name="l01219"></a>01219         std::unique_ptr&lt;shader&gt; u_shader_ptr;
<a name="l01220"></a>01220         std::unique_ptr&lt;shader&gt; v_shader_ptr;
<a name="l01221"></a>01221         std::unique_ptr&lt;shader&gt; wall_shader_ptr;
<a name="l01222"></a>01222         <span class="comment">// timings</span>
<a name="l01223"></a>01223         <a class="code" href="namespacelb.html#a664b98bd4013970d2005405e23ef78d9">time_point</a> start_time;
<a name="l01224"></a>01224         <a class="code" href="namespacelb.html#a664b98bd4013970d2005405e23ef78d9">time_point</a> last_display_time;
<a name="l01225"></a>01225         <span class="keywordtype">float</span> current_time;
<a name="l01226"></a>01226         <span class="keywordtype">float</span> dt;
<a name="l01227"></a>01227         std::vector&lt;float&gt; fps_hist;
<a name="l01228"></a>01228         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fps_hist_index;
<a name="l01229"></a>01229         <span class="comment">// data extent</span>
<a name="l01230"></a>01230         std::vector&lt;float&gt; rho_max_hist;
<a name="l01231"></a>01231         std::vector&lt;float&gt; rho_min_hist;
<a name="l01232"></a>01232         std::vector&lt;float&gt; u_max_hist;
<a name="l01233"></a>01233         std::vector&lt;float&gt; u_min_hist;
<a name="l01234"></a>01234         std::vector&lt;float&gt; v_max_hist;
<a name="l01235"></a>01235         std::vector&lt;float&gt; v_min_hist;
<a name="l01236"></a>01236         std::vector&lt;float&gt; vel_mag2_max_hist;
<a name="l01237"></a>01237         std::vector&lt;float&gt; vel_mag2_min_hist;
<a name="l01238"></a>01238         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data_hist_index;
<a name="l01239"></a>01239         <span class="comment">// limits for simulation data</span>
<a name="l01240"></a>01240         <span class="keywordtype">float</span> min_rho, max_rho, min_u, max_u, min_v, max_v, min_vel2, max_vel2;
<a name="l01241"></a>01241         <span class="comment">//particles</span>
<a name="l01242"></a>01242         std::list&lt;particle&gt; particle_list;
<a name="l01243"></a>01243         <span class="comment">// sate flags</span>
<a name="l01244"></a>01244         <span class="keywordtype">bool</span> running;
<a name="l01245"></a>01245         <span class="keyword">const</span> <span class="keywordtype">int</span> num_modes;
<a name="l01246"></a>01246         <span class="keywordtype">int</span> mode;
<a name="l01247"></a>01247         <span class="keywordtype">bool</span> start_particles;
<a name="l01248"></a>01248         <span class="keywordtype">bool</span> start_timeline;
<a name="l01249"></a>01249         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> picture_index;
<a name="l01250"></a>01250 };
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 std::unique_ptr&lt;visualization&gt; visualization::vis = <span class="keyword">nullptr</span>;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 } <span class="comment">// lb</span>
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="preprocessor">#endif // LB_VISUALIZATION_HPP_INCLUDED</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 17 2013 19:11:39 for LB2D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
